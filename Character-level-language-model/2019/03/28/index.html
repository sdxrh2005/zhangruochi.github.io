<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PingFang SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangruochi.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Practice of LSTM, learn from text data of dinosaur names and then generate the new names.">
<meta property="og:type" content="article">
<meta property="og:title" content="Character-level language model">
<meta property="og:url" content="https://zhangruochi.com/Character-level-language-model/2019/03/28/index.html">
<meta property="og:site_name" content="RUOCHI.AI">
<meta property="og:description" content="Practice of LSTM, learn from text data of dinosaur names and then generate the new names.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhangruochi.com/Character-level-language-model/2019/03/28/images/dino.jpg">
<meta property="og:image" content="https://zhangruochi.com/Character-level-language-model/2019/03/28/images/rnn.png">
<meta property="og:image" content="https://zhangruochi.com/Character-level-language-model/2019/03/28/images/clip.png">
<meta property="og:image" content="https://zhangruochi.com/Character-level-language-model/2019/03/28/images/dinos3.png">
<meta property="og:image" content="https://zhangruochi.com/Character-level-language-model/2019/03/28/images/mangosaurus.jpeg">
<meta property="og:image" content="https://zhangruochi.com/Character-level-language-model/2019/03/28/images/shakespeare.jpg">
<meta property="article:published_time" content="2019-03-28T08:12:16.000Z">
<meta property="article:modified_time" content="2019-07-05T10:32:07.568Z">
<meta property="article:author" content="Ruochi Zhang">
<meta property="article:tag" content="Sequence Models">
<meta property="article:tag" content="Project">
<meta property="article:tag" content="NLP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangruochi.com/Character-level-language-model/2019/03/28/images/dino.jpg">

<link rel="canonical" href="https://zhangruochi.com/Character-level-language-model/2019/03/28/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Character-level language model | RUOCHI.AI</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RUOCHI.AI</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhangruochi.com/Character-level-language-model/2019/03/28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ruochi Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RUOCHI.AI">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Character-level language model
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-28 16:12:16" itemprop="dateCreated datePublished" datetime="2019-03-28T16:12:16+08:00">2019-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-07-05 18:32:07" itemprop="dateModified" datetime="2019-07-05T18:32:07+08:00">2019-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Artificial-Intelligence/" itemprop="url" rel="index"><span itemprop="name">Artificial Intelligence</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Artificial-Intelligence/Deep-Learning/" itemprop="url" rel="index"><span itemprop="name">Deep Learning</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Character-level-language-model/2019/03/28/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Character-level-language-model/2019/03/28/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">Practice of LSTM, learn from text data of dinosaur names and then generate the new names.</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="character-level-language-model---dinosaurus-land">Character level language model - Dinosaurus land</h1>
<p>Welcome to Dinosaurus Island! 65 million years ago, dinosaurs existed, and in this assignment they are back. You are in charge of a special task. Leading biology researchers are creating new breeds of dinosaurs and bringing them to life on earth, and your job is to give names to these dinosaurs. If a dinosaur does not like its name, it might go beserk, so choose wisely!</p>
<table>
<td>
<p><img src="images/dino.jpg" style="width:250;height:300px;"></p>
</td>
</table>
<p>Luckily you have learned some deep learning and you will use it to save the day. Your assistant has collected a list of all the dinosaur names they could find, and compiled them into this <a href="dinos.txt">dataset</a>. (Feel free to take a look by clicking the previous link.) To create new dinosaur names, you will build a character level language model to generate new names. Your algorithm will learn the different name patterns, and randomly generate new names. Hopefully this algorithm will keep you and your team safe from the dinosaurs' wrath!</p>
<p>By completing this assignment you will learn:</p>
<ul>
<li>How to store text data for processing using an RNN</li>
<li>How to synthesize data, by sampling predictions at each time step and passing it to the next RNN-cell unit</li>
<li>How to build a character-level text generation recurrent neural network</li>
<li>Why clipping the gradients is important</li>
</ul>
<p>We will begin by loading in some functions that we have provided for you in <code>rnn_utils</code>. Specifically, you have access to functions such as <code>rnn_forward</code> and <code>rnn_backward</code> which are equivalent to those you've implemented in the previous assignment.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br></pre></td></tr></table></figure>
<h2 id="problem-statement">1 - Problem Statement</h2>
<h3 id="dataset-and-preprocessing">1.1 - Dataset and Preprocessing</h3>
<p>Run the following cell to read the dataset of dinosaur names, create a list of unique characters (such as a-z), and compute the dataset and vocabulary size.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="built_in">open</span>(<span class="string">&#x27;dinos.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line">data= data.lower()</span><br><span class="line">chars = <span class="built_in">list</span>(<span class="built_in">set</span>(data))</span><br><span class="line">data_size, vocab_size = <span class="built_in">len</span>(data), <span class="built_in">len</span>(chars)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;There are %d total characters and %d unique characters in your data.&#x27;</span> % (data_size, vocab_size))</span><br></pre></td></tr></table></figure>
<pre><code>There are 19909 total characters and 27 unique characters in your data.</code></pre>
<p>The characters are a-z (26 characters) plus the "" (or newline character), which in this assignment plays a role similar to the <code>&lt;EOS&gt;</code> (or "End of sentence") token we had discussed in lecture, only here it indicates the end of the dinosaur name rather than the end of a sentence. In the cell below, we create a python dictionary (i.e., a hash table) to map each character to an index from 0-26. We also create a second python dictionary that maps each index back to the corresponding character character. This will help you figure out what index corresponds to what character in the probability distribution output of the softmax layer. Below, <code>char_to_ix</code> and <code>ix_to_char</code> are the python dictionaries.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char_to_ix = &#123; ch:i <span class="keyword">for</span> i,ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">sorted</span>(chars)) &#125;</span><br><span class="line">ix_to_char = &#123; i:ch <span class="keyword">for</span> i,ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">sorted</span>(chars)) &#125;</span><br><span class="line"><span class="built_in">print</span>(ix_to_char)</span><br></pre></td></tr></table></figure>
<pre><code>&#123;0: &#39;\n&#39;, 1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;, 5: &#39;e&#39;, 6: &#39;f&#39;, 7: &#39;g&#39;, 8: &#39;h&#39;, 9: &#39;i&#39;, 10: &#39;j&#39;, 11: &#39;k&#39;, 12: &#39;l&#39;, 13: &#39;m&#39;, 14: &#39;n&#39;, 15: &#39;o&#39;, 16: &#39;p&#39;, 17: &#39;q&#39;, 18: &#39;r&#39;, 19: &#39;s&#39;, 20: &#39;t&#39;, 21: &#39;u&#39;, 22: &#39;v&#39;, 23: &#39;w&#39;, 24: &#39;x&#39;, 25: &#39;y&#39;, 26: &#39;z&#39;&#125;</code></pre>
<h3 id="overview-of-the-model">1.2 - Overview of the model</h3>
<p>Your model will have the following structure:</p>
<ul>
<li>Initialize parameters</li>
<li>Run the optimization loop
<ul>
<li>Forward propagation to compute the loss function</li>
<li>Backward propagation to compute the gradients with respect to the loss function</li>
<li>Clip the gradients to avoid exploding gradients</li>
<li>Using the gradients, update your parameter with the gradient descent update rule.</li>
</ul></li>
<li>Return the learned parameters</li>
</ul>
<img src="images/rnn.png" style="width:450;height:300px;">
<caption>
<center>
<strong>Figure 1</strong>: Recurrent Neural Network, similar to what you had built in the previous notebook "Building a RNN - Step by Step".
</center>
</caption>
<p>At each time-step, the RNN tries to predict what is the next character given the previous characters. The dataset <span class="math inline">\(X = (x^{\langle 1 \rangle}, x^{\langle 2 \rangle}, ..., x^{\langle T_x \rangle})\)</span> is a list of characters in the training set, while <span class="math inline">\(Y = (y^{\langle 1 \rangle}, y^{\langle 2 \rangle}, ..., y^{\langle T_x \rangle})\)</span> is such that at every time-step <span class="math inline">\(t\)</span>, we have <span class="math inline">\(y^{\langle t \rangle} = x^{\langle t+1 \rangle}\)</span>.</p>
<h2 id="building-blocks-of-the-model">2 - Building blocks of the model</h2>
<p>In this part, you will build two important blocks of the overall model: - Gradient clipping: to avoid exploding gradients - Sampling: a technique used to generate characters</p>
<p>You will then apply these two functions to build the model.</p>
<h3 id="clipping-the-gradients-in-the-optimization-loop">2.1 - Clipping the gradients in the optimization loop</h3>
<p>In this section you will implement the <code>clip</code> function that you will call inside of your optimization loop. Recall that your overall loop structure usually consists of a forward pass, a cost computation, a backward pass, and a parameter update. Before updating the parameters, you will perform gradient clipping when needed to make sure that your gradients are not "exploding," meaning taking on overly large values.</p>
<p>In the exercise below, you will implement a function <code>clip</code> that takes in a dictionary of gradients and returns a clipped version of gradients if needed. There are different ways to clip gradients; we will use a simple element-wise clipping procedure, in which every element of the gradient vector is clipped to lie between some range [-N, N]. More generally, you will provide a <code>maxValue</code> (say 10). In this example, if any component of the gradient vector is greater than 10, it would be set to 10; and if any component of the gradient vector is less than -10, it would be set to -10. If it is between -10 and 10, it is left alone.</p>
<img src="images/clip.png" style="width:400;height:150px;">
<caption>
<center>
<strong>Figure 2</strong>: Visualization of gradient descent with and without gradient clipping, in a case where the network is running into slight "exploding gradient" problems.
</center>
</caption>
<p><strong>Exercise</strong>: Implement the function below to return the clipped gradients of your dictionary <code>gradients</code>. Your function takes in a maximum threshold and returns the clipped versions of your gradients. You can check out this <a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.clip.html">hint</a> for examples of how to clip in numpy. You will need to use the argument <code>out = ...</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### GRADED FUNCTION: clip</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clip</span>(<span class="params">gradients, maxValue</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Clips the gradients&#x27; values between minimum and maximum.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    gradients -- a dictionary containing the gradients &quot;dWaa&quot;, &quot;dWax&quot;, &quot;dWya&quot;, &quot;db&quot;, &quot;dby&quot;</span></span><br><span class="line"><span class="string">    maxValue -- everything above this number is set to this number, and everything less than -maxValue is set to -maxValue</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns: </span></span><br><span class="line"><span class="string">    gradients -- a dictionary with the clipped gradients.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    dWaa, dWax, dWya, db, dby = gradients[<span class="string">&#x27;dWaa&#x27;</span>], gradients[<span class="string">&#x27;dWax&#x27;</span>], gradients[<span class="string">&#x27;dWya&#x27;</span>], gradients[<span class="string">&#x27;db&#x27;</span>], gradients[<span class="string">&#x27;dby&#x27;</span>]</span><br><span class="line">   </span><br><span class="line">    <span class="comment">### START CODE HERE ###</span></span><br><span class="line">    <span class="comment"># clip to mitigate exploding gradients, loop over [dWax, dWaa, dWya, db, dby]. (≈2 lines)</span></span><br><span class="line">    <span class="keyword">for</span> gradient <span class="keyword">in</span> [dWax, dWaa, dWya, db, dby]:</span><br><span class="line">        np.clip(a = gradient, a_min = -maxValue, a_max = maxValue, out = gradient)</span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    gradients = &#123;<span class="string">&quot;dWaa&quot;</span>: dWaa, <span class="string">&quot;dWax&quot;</span>: dWax, <span class="string">&quot;dWya&quot;</span>: dWya, <span class="string">&quot;db&quot;</span>: db, <span class="string">&quot;dby&quot;</span>: dby&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gradients</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">3</span>)</span><br><span class="line">dWax = np.random.randn(<span class="number">5</span>,<span class="number">3</span>)*<span class="number">10</span></span><br><span class="line">dWaa = np.random.randn(<span class="number">5</span>,<span class="number">5</span>)*<span class="number">10</span></span><br><span class="line">dWya = np.random.randn(<span class="number">2</span>,<span class="number">5</span>)*<span class="number">10</span></span><br><span class="line">db = np.random.randn(<span class="number">5</span>,<span class="number">1</span>)*<span class="number">10</span></span><br><span class="line">dby = np.random.randn(<span class="number">2</span>,<span class="number">1</span>)*<span class="number">10</span></span><br><span class="line">gradients = &#123;<span class="string">&quot;dWax&quot;</span>: dWax, <span class="string">&quot;dWaa&quot;</span>: dWaa, <span class="string">&quot;dWya&quot;</span>: dWya, <span class="string">&quot;db&quot;</span>: db, <span class="string">&quot;dby&quot;</span>: dby&#125;</span><br><span class="line">gradients = clip(gradients, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gradients[\&quot;dWaa\&quot;][1][2] =&quot;</span>, gradients[<span class="string">&quot;dWaa&quot;</span>][<span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gradients[\&quot;dWax\&quot;][3][1] =&quot;</span>, gradients[<span class="string">&quot;dWax&quot;</span>][<span class="number">3</span>][<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gradients[\&quot;dWya\&quot;][1][2] =&quot;</span>, gradients[<span class="string">&quot;dWya&quot;</span>][<span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gradients[\&quot;db\&quot;][4] =&quot;</span>, gradients[<span class="string">&quot;db&quot;</span>][<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gradients[\&quot;dby\&quot;][1] =&quot;</span>, gradients[<span class="string">&quot;dby&quot;</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<pre><code>gradients[&quot;dWaa&quot;][1][2] = 10.0
gradients[&quot;dWax&quot;][3][1] = -10.0
gradients[&quot;dWya&quot;][1][2] = 0.29713815361
gradients[&quot;db&quot;][4] = [ 10.]
gradients[&quot;dby&quot;][1] = [ 8.45833407]</code></pre>
<p>** Expected output:**</p>
<table>
<tr>
<td>
<strong>gradients["dWaa"][1][2] </strong>
</td>
<td>
10.0
</td>
</tr>
<tr>
<td>
<strong>gradients["dWax"][3][1]</strong>
</td>
<td>
-10.0
</td>
</td>
</tr>
<tr>
<td>
<strong>gradients["dWya"][1][2]</strong>
</td>
<td>
0.29713815361
</td>
</tr>
<tr>
<td>
<strong>gradients["db"][4]</strong>
</td>
<td>
[ 10.]
</td>
</tr>
<tr>
<td>
<strong>gradients["dby"][1]</strong>
</td>
<td>
[ 8.45833407]
</td>
</tr>
</table>
<h3 id="sampling">2.2 - Sampling</h3>
<p>Now assume that your model is trained. You would like to generate new text (characters). The process of generation is explained in the picture below:</p>
<img src="images/dinos3.png" style="width:500;height:300px;">
<caption>
<center>
<strong>Figure 3</strong>: In this picture, we assume the model is already trained. We pass in <span class="math inline">\(x^{\langle 1\rangle} = \vec{0}\)</span> at the first time step, and have the network then sample one character at a time.
</center>
</caption>
<p><strong>Exercise</strong>: Implement the <code>sample</code> function below to sample characters. You need to carry out 4 steps:</p>
<ul>
<li><p><strong>Step 1</strong>: Pass the network the first "dummy" input <span class="math inline">\(x^{\langle 1 \rangle} = \vec{0}\)</span> (the vector of zeros). This is the default input before we've generated any characters. We also set <span class="math inline">\(a^{\langle 0 \rangle} = \vec{0}\)</span></p></li>
<li><p><strong>Step 2</strong>: Run one step of forward propagation to get <span class="math inline">\(a^{\langle 1 \rangle}\)</span> and <span class="math inline">\(\hat{y}^{\langle 1 \rangle}\)</span>. Here are the equations:</p></li>
</ul>
<p><span class="math display">\[ a^{\langle t+1 \rangle} = \tanh(W_{ax}  x^{\langle t \rangle } + W_{aa} a^{\langle t \rangle } + b)\tag{1}\]</span></p>
<p><span class="math display">\[ z^{\langle t + 1 \rangle } = W_{ya}  a^{\langle t + 1 \rangle } + b_y \tag{2}\]</span></p>
<p><span class="math display">\[ \hat{y}^{\langle t+1 \rangle } = softmax(z^{\langle t + 1 \rangle })\tag{3}\]</span></p>
<p>Note that <span class="math inline">\(\hat{y}^{\langle t+1 \rangle }\)</span> is a (softmax) probability vector (its entries are between 0 and 1 and sum to 1). <span class="math inline">\(\hat{y}^{\langle t+1 \rangle}_i\)</span> represents the probability that the character indexed by "i" is the next character. We have provided a <code>softmax()</code> function that you can use.</p>
<ul>
<li><strong>Step 3</strong>: Carry out sampling: Pick the next character's index according to the probability distribution specified by <span class="math inline">\(\hat{y}^{\langle t+1 \rangle }\)</span>. This means that if <span class="math inline">\(\hat{y}^{\langle t+1 \rangle }_i = 0.16\)</span>, you will pick the index "i" with 16% probability. To implement it, you can use <a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.random.choice.html"><code>np.random.choice</code></a>.</li>
</ul>
<p>Here is an example of how to use <code>np.random.choice()</code>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">p = np.array([<span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.7</span>, <span class="number">0.2</span>])</span><br><span class="line">index = np.random.choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], p = p.ravel())</span><br></pre></td></tr></table></figure> This means that you will pick the <code>index</code> according to the distribution: <span class="math inline">\(P(index = 0) = 0.1, P(index = 1) = 0.0, P(index = 2) = 0.7, P(index = 3) = 0.2\)</span>.</p>
<ul>
<li><strong>Step 4</strong>: The last step to implement in <code>sample()</code> is to overwrite the variable <code>x</code>, which currently stores <span class="math inline">\(x^{\langle t \rangle }\)</span>, with the value of <span class="math inline">\(x^{\langle t + 1 \rangle }\)</span>. You will represent <span class="math inline">\(x^{\langle t + 1 \rangle }\)</span> by creating a one-hot vector corresponding to the character you've chosen as your prediction. You will then forward propagate <span class="math inline">\(x^{\langle t + 1 \rangle }\)</span> in Step 1 and keep repeating the process until you get a "" character, indicating you've reached the end of the dinosaur name.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: sample</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span>(<span class="params">parameters, char_to_ix, seed</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Sample a sequence of characters according to a sequence of probability distributions output of the RNN</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    parameters -- python dictionary containing the parameters Waa, Wax, Wya, by, and b. </span></span><br><span class="line"><span class="string">    char_to_ix -- python dictionary mapping each character to an index.</span></span><br><span class="line"><span class="string">    seed -- used for grading purposes. Do not worry about it.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    indices -- a list of length n containing the indices of the sampled characters.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve parameters and relevant shapes from &quot;parameters&quot; dictionary</span></span><br><span class="line">    Waa, Wax, Wya, by, b = parameters[<span class="string">&#x27;Waa&#x27;</span>], parameters[<span class="string">&#x27;Wax&#x27;</span>], parameters[<span class="string">&#x27;Wya&#x27;</span>], parameters[<span class="string">&#x27;by&#x27;</span>], parameters[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment">#     print(Waa.shape)</span></span><br><span class="line"><span class="comment">#     print(Wax.shape)</span></span><br><span class="line"><span class="comment">#     print(Wya.shape)</span></span><br><span class="line"><span class="comment">#     print(by.shape)</span></span><br><span class="line">    </span><br><span class="line">    vocab_size = by.shape[<span class="number">0</span>]</span><br><span class="line">    n_a = Waa.shape[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ###</span></span><br><span class="line">    <span class="comment"># Step 1: Create the one-hot vector x for the first character (initializing the sequence generation). (≈1 line)</span></span><br><span class="line">    x = np.zeros((vocab_size,<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># Step 1&#x27;: Initialize a_prev as zeros (≈1 line)</span></span><br><span class="line">    a_prev = np.zeros((n_a,<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Create an empty list of indices, this is the list which will contain the list of indices of the characters to generate (≈1 line)</span></span><br><span class="line">    indices = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Idx is a flag to detect a newline character, we initialize it to -1</span></span><br><span class="line">    idx = -<span class="number">1</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Loop over time-steps t. At each time-step, sample a character from a probability distribution and append </span></span><br><span class="line">    <span class="comment"># its index to &quot;indices&quot;. We&#x27;ll stop if we reach 50 characters (which should be very unlikely with a well </span></span><br><span class="line">    <span class="comment"># trained model), which helps debugging and prevents entering an infinite loop. </span></span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    newline_character = char_to_ix[<span class="string">&#x27;\n&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (idx != newline_character <span class="keyword">and</span> counter != <span class="number">50</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 2: Forward propagate x using the equations (1), (2) and (3)</span></span><br><span class="line">        a = np.tanh(np.dot(Wax,x) + np.dot(Waa,a_prev)+b)</span><br><span class="line">        z = np.dot(Wya,a) + by</span><br><span class="line">        y = softmax(z)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># for grading purposes</span></span><br><span class="line">        np.random.seed(counter+seed) </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 3: Sample the index of a character within the vocabulary from the probability distribution y</span></span><br><span class="line">        idx = np.random.choice(<span class="built_in">list</span>(<span class="built_in">range</span>(y.shape[<span class="number">0</span>])), p = y.ravel())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Append the index to &quot;indices&quot;</span></span><br><span class="line">        indices.append(idx)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Step 4: Overwrite the input character as the one corresponding to the sampled index.</span></span><br><span class="line">        x = np.zeros((vocab_size,<span class="number">1</span>))</span><br><span class="line">        x[idx] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Update &quot;a_prev&quot; to be &quot;a&quot;</span></span><br><span class="line">        a_prev = a</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># for grading purposes</span></span><br><span class="line">        seed += <span class="number">1</span></span><br><span class="line">        counter +=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">50</span>):</span><br><span class="line">        indices.append(char_to_ix[<span class="string">&#x27;\n&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> indices</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">2</span>)</span><br><span class="line">_, n_a = <span class="number">20</span>, <span class="number">100</span></span><br><span class="line">Wax, Waa, Wya = np.random.randn(n_a, vocab_size), np.random.randn(n_a, n_a), np.random.randn(vocab_size, n_a)</span><br><span class="line">b, by = np.random.randn(n_a, <span class="number">1</span>), np.random.randn(vocab_size, <span class="number">1</span>)</span><br><span class="line">parameters = &#123;<span class="string">&quot;Wax&quot;</span>: Wax, <span class="string">&quot;Waa&quot;</span>: Waa, <span class="string">&quot;Wya&quot;</span>: Wya, <span class="string">&quot;b&quot;</span>: b, <span class="string">&quot;by&quot;</span>: by&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">indices = sample(parameters, char_to_ix, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sampling:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;list of sampled indices:&quot;</span>, indices)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;list of sampled characters:&quot;</span>, [ix_to_char[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices])</span><br></pre></td></tr></table></figure>
<pre><code>Sampling:
list of sampled indices: [12, 17, 24, 14, 13, 9, 10, 22, 24, 6, 13, 11, 12, 6, 21, 15, 21, 14, 3, 2, 1, 21, 18, 24, 7, 25, 6, 25, 18, 10, 16, 2, 3, 8, 15, 12, 11, 7, 1, 12, 10, 2, 7, 7, 11, 5, 6, 12, 25, 0, 0]
list of sampled characters: [&#39;l&#39;, &#39;q&#39;, &#39;x&#39;, &#39;n&#39;, &#39;m&#39;, &#39;i&#39;, &#39;j&#39;, &#39;v&#39;, &#39;x&#39;, &#39;f&#39;, &#39;m&#39;, &#39;k&#39;, &#39;l&#39;, &#39;f&#39;, &#39;u&#39;, &#39;o&#39;, &#39;u&#39;, &#39;n&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;, &#39;u&#39;, &#39;r&#39;, &#39;x&#39;, &#39;g&#39;, &#39;y&#39;, &#39;f&#39;, &#39;y&#39;, &#39;r&#39;, &#39;j&#39;, &#39;p&#39;, &#39;b&#39;, &#39;c&#39;, &#39;h&#39;, &#39;o&#39;, &#39;l&#39;, &#39;k&#39;, &#39;g&#39;, &#39;a&#39;, &#39;l&#39;, &#39;j&#39;, &#39;b&#39;, &#39;g&#39;, &#39;g&#39;, &#39;k&#39;, &#39;e&#39;, &#39;f&#39;, &#39;l&#39;, &#39;y&#39;, &#39;\n&#39;, &#39;\n&#39;]</code></pre>
** Expected output:**
<table>
<tr>
<td>
<strong>list of sampled indices:</strong>
</td>
<td>
[12, 17, 24, 14, 13, 9, 10, 22, 24, 6, 13, 11, 12, 6, 21, 15, 21, 14, 3, 2, 1, 21, 18, 24, <br> 7, 25, 6, 25, 18, 10, 16, 2, 3, 8, 15, 12, 11, 7, 1, 12, 10, 2, 7, 7, 11, 5, 6, 12, 25, 0, 0]
</td>
</tr>
<tr>
<td>
<strong>list of sampled characters:</strong>
</td>
<td>
['l', 'q', 'x', 'n', 'm', 'i', 'j', 'v', 'x', 'f', 'm', 'k', 'l', 'f', 'u', 'o', <br> 'u', 'n', 'c', 'b', 'a', 'u', 'r', 'x', 'g', 'y', 'f', 'y', 'r', 'j', 'p', 'b', 'c', 'h', 'o', <br> 'l', 'k', 'g', 'a', 'l', 'j', 'b', 'g', 'g', 'k', 'e', 'f', 'l', 'y', '', '']
</td>
</tr>
</table>
<h2 id="building-the-language-model">3 - Building the language model</h2>
<p>It is time to build the character-level language model for text generation.</p>
<h3 id="gradient-descent">3.1 - Gradient descent</h3>
<p>In this section you will implement a function performing one step of stochastic gradient descent (with clipped gradients). You will go through the training examples one at a time, so the optimization algorithm will be stochastic gradient descent. As a reminder, here are the steps of a common optimization loop for an RNN:</p>
<ul>
<li>Forward propagate through the RNN to compute the loss</li>
<li>Backward propagate through time to compute the gradients of the loss with respect to the parameters</li>
<li>Clip the gradients if necessary</li>
<li>Update your parameters using gradient descent</li>
</ul>
<p><strong>Exercise</strong>: Implement this optimization process (one step of stochastic gradient descent).</p>
<p>We provide you with the following functions:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rnn_forward</span>(<span class="params">X, Y, a_prev, parameters</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Performs the forward propagation through the RNN and computes the cross-entropy loss.</span></span><br><span class="line"><span class="string">    It returns the loss&#x27; value as well as a &quot;cache&quot; storing values to be used in the backpropagation.&quot;&quot;&quot;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> loss, cache</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rnn_backward</span>(<span class="params">X, Y, parameters, cache</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Performs the backward propagation through time to compute the gradients of the loss with respect</span></span><br><span class="line"><span class="string">    to the parameters. It returns also all the hidden states.&quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> gradients, a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_parameters</span>(<span class="params">parameters, gradients, learning_rate</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Updates parameters using the Gradient Descent Update Rule.&quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: optimize</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimize</span>(<span class="params">X, Y, a_prev, parameters, learning_rate = <span class="number">0.01</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Execute one step of the optimization to train the model.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    X -- list of integers, where each integer is a number that maps to a character in the vocabulary.</span></span><br><span class="line"><span class="string">    Y -- list of integers, exactly the same as X but shifted one index to the left.</span></span><br><span class="line"><span class="string">    a_prev -- previous hidden state.</span></span><br><span class="line"><span class="string">    parameters -- python dictionary containing:</span></span><br><span class="line"><span class="string">                        Wax -- Weight matrix multiplying the input, numpy array of shape (n_a, n_x)</span></span><br><span class="line"><span class="string">                        Waa -- Weight matrix multiplying the hidden state, numpy array of shape (n_a, n_a)</span></span><br><span class="line"><span class="string">                        Wya -- Weight matrix relating the hidden-state to the output, numpy array of shape (n_y, n_a)</span></span><br><span class="line"><span class="string">                        b --  Bias, numpy array of shape (n_a, 1)</span></span><br><span class="line"><span class="string">                        by -- Bias relating the hidden-state to the output, numpy array of shape (n_y, 1)</span></span><br><span class="line"><span class="string">    learning_rate -- learning rate for the model.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    loss -- value of the loss function (cross-entropy)</span></span><br><span class="line"><span class="string">    gradients -- python dictionary containing:</span></span><br><span class="line"><span class="string">                        dWax -- Gradients of input-to-hidden weights, of shape (n_a, n_x)</span></span><br><span class="line"><span class="string">                        dWaa -- Gradients of hidden-to-hidden weights, of shape (n_a, n_a)</span></span><br><span class="line"><span class="string">                        dWya -- Gradients of hidden-to-output weights, of shape (n_y, n_a)</span></span><br><span class="line"><span class="string">                        db -- Gradients of bias vector, of shape (n_a, 1)</span></span><br><span class="line"><span class="string">                        dby -- Gradients of output bias vector, of shape (n_y, 1)</span></span><br><span class="line"><span class="string">    a[len(X)-1] -- the last hidden state, of shape (n_a, 1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">### START CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Forward propagate through time (≈1 line)</span></span><br><span class="line">    loss, cache = rnn_forward(X, Y, a_prev, parameters)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Backpropagate through time (≈1 line)</span></span><br><span class="line">    gradients, a = rnn_backward(X, Y, parameters, cache)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Clip your gradients between -5 (min) and 5 (max) (≈1 line)</span></span><br><span class="line">    gradients = clip(gradients, <span class="number">5</span>)</span><br><span class="line">    <span class="comment"># Update parameters (≈1 line)</span></span><br><span class="line">    parameters = update_parameters(parameters, gradients, learning_rate)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> loss, gradients, a[<span class="built_in">len</span>(X)-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">vocab_size, n_a = <span class="number">27</span>, <span class="number">100</span></span><br><span class="line">a_prev = np.random.randn(n_a, <span class="number">1</span>)</span><br><span class="line">Wax, Waa, Wya = np.random.randn(n_a, vocab_size), np.random.randn(n_a, n_a), np.random.randn(vocab_size, n_a)</span><br><span class="line">b, by = np.random.randn(n_a, <span class="number">1</span>), np.random.randn(vocab_size, <span class="number">1</span>)</span><br><span class="line">parameters = &#123;<span class="string">&quot;Wax&quot;</span>: Wax, <span class="string">&quot;Waa&quot;</span>: Waa, <span class="string">&quot;Wya&quot;</span>: Wya, <span class="string">&quot;b&quot;</span>: b, <span class="string">&quot;by&quot;</span>: by&#125;</span><br><span class="line">X = [<span class="number">12</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">3</span>]</span><br><span class="line">Y = [<span class="number">4</span>,<span class="number">14</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">25</span>, <span class="number">26</span>]</span><br><span class="line"></span><br><span class="line">loss, gradients, a_last = optimize(X, Y, a_prev, parameters, learning_rate = <span class="number">0.01</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Loss =&quot;</span>, loss)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gradients[\&quot;dWaa\&quot;][1][2] =&quot;</span>, gradients[<span class="string">&quot;dWaa&quot;</span>][<span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;np.argmax(gradients[\&quot;dWax\&quot;]) =&quot;</span>, np.argmax(gradients[<span class="string">&quot;dWax&quot;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gradients[\&quot;dWya\&quot;][1][2] =&quot;</span>, gradients[<span class="string">&quot;dWya&quot;</span>][<span class="number">1</span>][<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gradients[\&quot;db\&quot;][4] =&quot;</span>, gradients[<span class="string">&quot;db&quot;</span>][<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gradients[\&quot;dby\&quot;][1] =&quot;</span>, gradients[<span class="string">&quot;dby&quot;</span>][<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a_last[4] =&quot;</span>, a_last[<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<pre><code>Loss = 126.503975722
gradients[&quot;dWaa&quot;][1][2] = 0.194709315347
np.argmax(gradients[&quot;dWax&quot;]) = 93
gradients[&quot;dWya&quot;][1][2] = -0.007773876032
gradients[&quot;db&quot;][4] = [-0.06809825]
gradients[&quot;dby&quot;][1] = [ 0.01538192]
a_last[4] = [-1.]</code></pre>
<p>** Expected output:**</p>
<table>
<tr>
<td>
<strong>Loss </strong>
</td>
<td>
126.503975722
</td>
</tr>
<tr>
<td>
<strong>gradients["dWaa"][1][2]</strong>
</td>
<td>
0.194709315347
</td>
<tr>
<td>
<strong>np.argmax(gradients["dWax"])</strong>
</td>
<td>
93
</td>
</tr>
<tr>
<td>
<strong>gradients["dWya"][1][2]</strong>
</td>
<td>
-0.007773876032
</td>
</tr>
<tr>
<td>
<strong>gradients["db"][4]</strong>
</td>
<td>
[-0.06809825]
</td>
</tr>
<tr>
<td>
<strong>gradients["dby"][1]</strong>
</td>
<td>
[ 0.01538192]
</td>
</tr>
<tr>
<td>
<strong>a_last[4]</strong>
</td>
<td>
[-1.]
</td>
</tr>
</table>
<h3 id="training-the-model">3.2 - Training the model</h3>
<p>Given the dataset of dinosaur names, we use each line of the dataset (one name) as one training example. Every 100 steps of stochastic gradient descent, you will sample 10 randomly chosen names to see how the algorithm is doing. Remember to shuffle the dataset, so that stochastic gradient descent visits the examples in random order.</p>
<p><strong>Exercise</strong>: Follow the instructions and implement <code>model()</code>. When <code>examples[index]</code> contains one dinosaur name (string), to create an example (X, Y), you can use this: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index = j % <span class="built_in">len</span>(examples)</span><br><span class="line">X = [<span class="literal">None</span>] + [char_to_ix[ch] <span class="keyword">for</span> ch <span class="keyword">in</span> examples[index]] </span><br><span class="line">Y = X[<span class="number">1</span>:] + [char_to_ix[<span class="string">&quot;\n&quot;</span>]]</span><br></pre></td></tr></table></figure> Note that we use: <code>index= j % len(examples)</code>, where <code>j = 1....num_iterations</code>, to make sure that <code>examples[index]</code> is always a valid statement (<code>index</code> is smaller than <code>len(examples)</code>). The first entry of <code>X</code> being <code>None</code> will be interpreted by <code>rnn_forward()</code> as setting <span class="math inline">\(x^{\langle 0 \rangle} = \vec{0}\)</span>. Further, this ensures that <code>Y</code> is equal to <code>X</code> but shifted one step to the left, and with an additional "" appended to signify the end of the dinosaur name.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: model</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span>(<span class="params">data, ix_to_char, char_to_ix, num_iterations = <span class="number">35000</span>, n_a = <span class="number">50</span>, dino_names = <span class="number">7</span>, vocab_size = <span class="number">27</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Trains the model and generates dinosaur names. </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">    data -- text corpus</span></span><br><span class="line"><span class="string">    ix_to_char -- dictionary that maps the index to a character</span></span><br><span class="line"><span class="string">    char_to_ix -- dictionary that maps a character to an index</span></span><br><span class="line"><span class="string">    num_iterations -- number of iterations to train the model for</span></span><br><span class="line"><span class="string">    n_a -- number of units of the RNN cell</span></span><br><span class="line"><span class="string">    dino_names -- number of dinosaur names you want to sample at each iteration. </span></span><br><span class="line"><span class="string">    vocab_size -- number of unique characters found in the text, size of the vocabulary</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    parameters -- learned parameters</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Retrieve n_x and n_y from vocab_size</span></span><br><span class="line">    n_x, n_y = vocab_size, vocab_size</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize parameters</span></span><br><span class="line">    parameters = initialize_parameters(n_a, n_x, n_y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize loss (this is required because we want to smooth our loss, don&#x27;t worry about it)</span></span><br><span class="line">    loss = get_initial_loss(vocab_size, dino_names)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Build list of all dinosaur names (training examples).</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;dinos.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        examples = f.readlines()</span><br><span class="line">    examples = [x.lower().strip() <span class="keyword">for</span> x <span class="keyword">in</span> examples]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Shuffle list of all dinosaur names</span></span><br><span class="line">    np.random.seed(<span class="number">0</span>)</span><br><span class="line">    np.random.shuffle(examples)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initialize the hidden state of your LSTM</span></span><br><span class="line">    a_prev = np.zeros((n_a, <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Optimization loop</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_iterations):</span><br><span class="line">        </span><br><span class="line">        <span class="comment">### START CODE HERE ###</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Use the hint above to define one training example (X,Y) (≈ 2 lines)</span></span><br><span class="line">        index = j % <span class="built_in">len</span>(examples)</span><br><span class="line">        X = [<span class="literal">None</span>] + [char_to_ix[ch] <span class="keyword">for</span> ch <span class="keyword">in</span> examples[index]]</span><br><span class="line">        Y = X[<span class="number">1</span>:] + [char_to_ix[<span class="string">&quot;\n&quot;</span>]]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Perform one optimization step: Forward-prop -&gt; Backward-prop -&gt; Clip -&gt; Update parameters</span></span><br><span class="line">        <span class="comment"># Choose a learning rate of 0.01</span></span><br><span class="line">        curr_loss, gradients, a_prev = optimize(X, Y, a_prev, parameters,learning_rate =  <span class="number">0.01</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">### END CODE HERE ###</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Use a latency trick to keep the loss smooth. It happens here to accelerate the training.</span></span><br><span class="line">        loss = smooth(loss, curr_loss)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Every 2000 Iteration, generate &quot;n&quot; characters thanks to sample() to check if the model is learning properly</span></span><br><span class="line">        <span class="keyword">if</span> j % <span class="number">2000</span> == <span class="number">0</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Iteration: %d, Loss: %f&#x27;</span> % (j, loss) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># The number of dinosaur names to print</span></span><br><span class="line">            seed = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">range</span>(dino_names):</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Sample indices and print them</span></span><br><span class="line">                sampled_indices = sample(parameters, char_to_ix, seed)</span><br><span class="line">                print_sample(sampled_indices, ix_to_char)</span><br><span class="line">                </span><br><span class="line">                seed += <span class="number">1</span>  <span class="comment"># To get the same result for grading purposed, increment the seed by one. </span></span><br><span class="line">      </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure>
<p>Run the following cell, you should observe your model outputting random-looking characters at the first iteration. After a few thousand iterations, your model should learn to generate reasonable-looking names.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameters = model(data, ix_to_char, char_to_ix)</span><br></pre></td></tr></table></figure>
<p>Iteration: 0, Loss: 23.087336</p>
<p>Nkzxwtdmfqoeyhsqwasjkjvu Kneb Kzxwtdmfqoeyhsqwasjkjvu Neb Zxwtdmfqoeyhsqwasjkjvu Eb Xwtdmfqoeyhsqwasjkjvu</p>
<p>Iteration: 2000, Loss: 27.884160</p>
<p>Liusskeomnolxeros Hmdaairus Hytroligoraurus Lecalosapaus Xusicikoraurus Abalpsamantisaurus Tpraneronxeros</p>
<p>Iteration: 4000, Loss: 25.901815</p>
<p>Mivrosaurus Inee Ivtroplisaurus Mbaaisaurus Wusichisaurus Cabaselachus Toraperlethosdarenitochusthiamamumamaon</p>
<p>Iteration: 6000, Loss: 24.608779</p>
<p>Onwusceomosaurus Lieeaerosaurus Lxussaurus Oma Xusteonosaurus Eeahosaurus Toreonosaurus</p>
<p>Iteration: 8000, Loss: 24.070350</p>
<p>Onxusichepriuon Kilabersaurus Lutrodon Omaaerosaurus Xutrcheps Edaksoje Trodiktonus</p>
<p>Iteration: 10000, Loss: 23.844446</p>
<p>Onyusaurus Klecalosaurus Lustodon Ola Xusodonia Eeaeosaurus Troceosaurus</p>
<p>Iteration: 12000, Loss: 23.291971</p>
<p>Onyxosaurus Kica Lustrepiosaurus Olaagrraiansaurus Yuspangosaurus Eealosaurus Trognesaurus</p>
<p>Iteration: 14000, Loss: 23.382339</p>
<p>Meutromodromurus Inda Iutroinatorsaurus Maca Yusteratoptititan Ca Troclosaurus</p>
<p>Iteration: 16000, Loss: 23.288447</p>
<p>Meuspsangosaurus Ingaa Iusosaurus Macalosaurus Yushanis Daalosaurus Trpandon</p>
<p>Iteration: 18000, Loss: 22.823526</p>
<p>Phytrolonhonyg Mela Mustrerasaurus Peg Ytronorosaurus Ehalosaurus Trolomeehus</p>
<p>Iteration: 20000, Loss: 23.041871</p>
<p>Nousmofonosaurus Loma Lytrognatiasaurus Ngaa Ytroenetiaudostarmilus Eiafosaurus Troenchulunosaurus</p>
<p>Iteration: 22000, Loss: 22.728849</p>
<p>Piutyrangosaurus Midaa Myroranisaurus Pedadosaurus Ytrodon Eiadosaurus Trodoniomusitocorces</p>
<p>Iteration: 24000, Loss: 22.683403</p>
<p>Meutromeisaurus Indeceratlapsaurus Jurosaurus Ndaa Yusicheropterus Eiaeropectus Trodonasaurus</p>
<p>Iteration: 26000, Loss: 22.554523</p>
<p>Phyusaurus Liceceron Lyusichenodylus Pegahus Yustenhtonthosaurus Elagosaurus Trodontonsaurus</p>
<p>Iteration: 28000, Loss: 22.484472</p>
<p>Onyutimaerihus Koia Lytusaurus Ola Ytroheltorus Eiadosaurus Trofiashates</p>
<p>Iteration: 30000, Loss: 22.774404</p>
<p>Phytys Lica Lysus Pacalosaurus Ytrochisaurus Eiacosaurus Trochesaurus</p>
<p>Iteration: 32000, Loss: 22.209473</p>
<p>Mawusaurus Jica Lustoia Macaisaurus Yusolenqtesaurus Eeaeosaurus Trnanatrax</p>
<p>Iteration: 34000, Loss: 22.396744</p>
<p>Mavptokekus Ilabaisaurus Itosaurus Macaesaurus Yrosaurus Eiaeosaurus Trodon</p>
<h2 id="conclusion">Conclusion</h2>
<p>You can see that your algorithm has started to generate plausible dinosaur names towards the end of the training. At first, it was generating random characters, but towards the end you could see dinosaur names with cool endings. Feel free to run the algorithm even longer and play with hyperparameters to see if you can get even better results. Our implemetation generated some really cool names like <code>maconucon</code>, <code>marloralus</code> and <code>macingsersaurus</code>. Your model hopefully also learned that dinosaur names tend to end in <code>saurus</code>, <code>don</code>, <code>aura</code>, <code>tor</code>, etc.</p>
<p>If your model generates some non-cool names, don't blame the model entirely--not all actual dinosaur names sound cool. (For example, <code>dromaeosauroides</code> is an actual dinosaur name and is in the training set.) But this model should give you a set of candidates from which you can pick the coolest!</p>
<p>This assignment had used a relatively small dataset, so that you could train an RNN quickly on a CPU. Training a model of the english language requires a much bigger dataset, and usually needs much more computation, and could run for many hours on GPUs. We ran our dinosaur name for quite some time, and so far our favoriate name is the great, undefeatable, and fierce: Mangosaurus!</p>
<p><img src="images/mangosaurus.jpeg" style="width:250;height:300px;"></p>
<h2 id="writing-like-shakespeare">4 - Writing like Shakespeare</h2>
<p>The rest of this notebook is optional and is not graded, but we hope you'll do it anyway since it's quite fun and informative.</p>
<p>A similar (but more complicated) task is to generate Shakespeare poems. Instead of learning from a dataset of Dinosaur names you can use a collection of Shakespearian poems. Using LSTM cells, you can learn longer term dependencies that span many characters in the text--e.g., where a character appearing somewhere a sequence can influence what should be a different character much much later in ths sequence. These long term dependencies were less important with dinosaur names, since the names were quite short.</p>
<img src="images/shakespeare.jpg" style="width:500;height:400px;">
<caption>
<center>
Let's become poets!
</center>
</caption>
<p>We have implemented a Shakespeare poem generator with Keras. Run the following cell to load the required packages and models. This may take a few minutes.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> keras.callbacks <span class="keyword">import</span> LambdaCallback</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Model, load_model, Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Activation, Dropout, Input, Masking</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> LSTM</span><br><span class="line"><span class="keyword">from</span> keras.utils.data_utils <span class="keyword">import</span> get_file</span><br><span class="line"><span class="keyword">from</span> keras.preprocessing.sequence <span class="keyword">import</span> pad_sequences</span><br><span class="line"><span class="keyword">from</span> shakespeare_utils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> io</span><br></pre></td></tr></table></figure>
<p>To save you some time, we have already trained a model for ~1000 epochs on a collection of Shakespearian poems called <a href="shakespeare.txt"><em>"The Sonnets"</em></a>.</p>
<p>Let's train the model for one more epoch. When it finishes training for an epoch---this will also take a few minutes---you can run <code>generate_output</code>, which will prompt asking you for an input (<code>&lt;</code>40 characters). The poem will start with your sentence, and our RNN-Shakespeare will complete the rest of the poem for you! For example, try "Forsooth this maketh no sense " (don't enter the quotation marks). Depending on whether you include the space at the end, your results might also differ--try it both ways, and try other inputs as well.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print_callback = LambdaCallback(on_epoch_end=on_epoch_end)</span><br><span class="line"></span><br><span class="line">model.fit(x, y, batch_size=<span class="number">128</span>, epochs=<span class="number">1</span>, callbacks=[print_callback])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run this cell to try with different inputs without having to re-train the model </span></span><br><span class="line">generate_output()</span><br></pre></td></tr></table></figure>
<p>The RNN-Shakespeare model is very similar to the one you have built for dinosaur names. The only major differences are: - LSTMs instead of the basic RNN to capture longer-range dependencies - The model is a deeper, stacked LSTM model (2 layer) - Using Keras instead of python to simplify the code</p>
<p>If you want to learn more, you can also check out the Keras Team's text generation implementation on GitHub: https://github.com/keras-team/keras/blob/master/examples/lstm_text_generation.py.</p>
<p>Congratulations on finishing this notebook!</p>
<p><strong>References</strong>: - This exercise took inspiration from Andrej Karpathy's implementation: https://gist.github.com/karpathy/d4dee566867f8291f086. To learn more about text generation, also check out Karpathy's <a target="_blank" rel="noopener" href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">blog post</a>. - For the Shakespearian poem generator, our implementation was based on the implementation of an LSTM text generator by the Keras team: https://github.com/keras-team/keras/blob/master/examples/lstm_text_generation.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Sequence-Models/" rel="tag"># Sequence Models</a>
              <a href="/tags/Project/" rel="tag"># Project</a>
              <a href="/tags/NLP/" rel="tag"># NLP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Convolutional-Neural-Networks/2019/03/27/" rel="prev" title="Convolutional Neural Networks">
      <i class="fa fa-chevron-left"></i> Convolutional Neural Networks
    </a></div>
      <div class="post-nav-item">
    <a href="/Improvise-a-Jazz-Solo-with-an-LSTM-Network/2019/03/28/" rel="next" title="Improvise a Jazz Solo with an LSTM Network">
      Improvise a Jazz Solo with an LSTM Network <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#character-level-language-model---dinosaurus-land"><span class="nav-number">1.</span> <span class="nav-text">Character level language model - Dinosaurus land</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-statement"><span class="nav-number">1.1.</span> <span class="nav-text">1 - Problem Statement</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dataset-and-preprocessing"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 - Dataset and Preprocessing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#overview-of-the-model"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 - Overview of the model</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#building-blocks-of-the-model"><span class="nav-number">1.2.</span> <span class="nav-text">2 - Building blocks of the model</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#clipping-the-gradients-in-the-optimization-loop"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 - Clipping the gradients in the optimization loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sampling"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 - Sampling</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#building-the-language-model"><span class="nav-number">1.3.</span> <span class="nav-text">3 - Building the language model</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gradient-descent"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 - Gradient descent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#training-the-model"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 - Training the model</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#conclusion"><span class="nav-number">1.4.</span> <span class="nav-text">Conclusion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#writing-like-shakespeare"><span class="nav-number">1.5.</span> <span class="nav-text">4 - Writing like Shakespeare</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ruochi Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">163</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangruochi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangruochi" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zrc720@gmail.com" title="E-Mail → mailto:zrc720@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.healthinformaticslab.org/" title="http:&#x2F;&#x2F;www.healthinformaticslab.org" rel="noopener" target="_blank">HILab</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.shihaizhou.com/" title="http:&#x2F;&#x2F;www.shihaizhou.com" rel="noopener" target="_blank">Rose</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/cherish_CX/" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;cherish_CX&#x2F;" rel="noopener" target="_blank">Chunxia</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ruochi Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qW3MLcAgcX96sB6qbegeL7rP-gzGzoHsz',
      appKey     : 'GL6JvT9DgGxqYrY5Vj6bXVuv',
      placeholder: "Thank you for your reply",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'en' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
