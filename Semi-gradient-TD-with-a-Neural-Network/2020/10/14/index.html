<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PingFang SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangruochi.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Assignment 2 - Semi-gradient TD with a Neural Network Welcome to Course 3 Programming Assignment 2. In the previous assignment, you implemented semi-gradient TD with State Aggregation for solving a po">
<meta property="og:type" content="article">
<meta property="og:title" content="Semi Gradient TD with a Neural Network">
<meta property="og:url" content="https://zhangruochi.com/Semi-gradient-TD-with-a-Neural-Network/2020/10/14/index.html">
<meta property="og:site_name" content="RUOCHI.AI">
<meta property="og:description" content="Assignment 2 - Semi-gradient TD with a Neural Network Welcome to Course 3 Programming Assignment 2. In the previous assignment, you implemented semi-gradient TD with State Aggregation for solving a po">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhangruochi.com/Semi-gradient-TD-with-a-Neural-Network/2020/10/14/nn_structure.png">
<meta property="og:image" content="https://zhangruochi.com/Semi-gradient-TD-with-a-Neural-Network/2020/10/14/output_39_2.png">
<meta property="og:image" content="https://zhangruochi.com/Semi-gradient-TD-with-a-Neural-Network/2020/10/14/nn_5000_episodes.png">
<meta property="og:image" content="https://zhangruochi.com/Semi-gradient-TD-with-a-Neural-Network/2020/10/14/nn_vs_tc.png">
<meta property="article:published_time" content="2020-10-14T09:18:55.000Z">
<meta property="article:modified_time" content="2020-10-16T07:04:08.000Z">
<meta property="article:author" content="Ruochi Zhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangruochi.com/Semi-gradient-TD-with-a-Neural-Network/2020/10/14/nn_structure.png">

<link rel="canonical" href="https://zhangruochi.com/Semi-gradient-TD-with-a-Neural-Network/2020/10/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Semi Gradient TD with a Neural Network | RUOCHI.AI</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RUOCHI.AI</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhangruochi.com/Semi-gradient-TD-with-a-Neural-Network/2020/10/14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ruochi Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RUOCHI.AI">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Semi Gradient TD with a Neural Network
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-14 17:18:55" itemprop="dateCreated datePublished" datetime="2020-10-14T17:18:55+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-16 15:04:08" itemprop="dateModified" datetime="2020-10-16T15:04:08+08:00">2020-10-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Artificial-Intelligence/" itemprop="url" rel="index"><span itemprop="name">Artificial Intelligence</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Artificial-Intelligence/Reinforcement-Learning/" itemprop="url" rel="index"><span itemprop="name">Reinforcement Learning</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Semi-gradient-TD-with-a-Neural-Network/2020/10/14/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Semi-gradient-TD-with-a-Neural-Network/2020/10/14/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="assignment-2---semi-gradient-td-with-a-neural-network">Assignment 2 - Semi-gradient TD with a Neural Network</h1>
<p>Welcome to Course 3 Programming Assignment 2. In the previous assignment, you implemented semi-gradient TD with State Aggregation for solving a <strong>policy evaluation task</strong>. In this assignment, you will implement <strong>semi-gradient TD with a simple Neural Network</strong> and use it for the same policy evaluation problem.</p>
<p>You will implement an agent to evaluate a fixed policy on the 500-State Randomwalk. As you may remember from the previous assignment, the 500-state Randomwalk includes 500 states. Each episode begins with the agent at the center and terminates when the agent goes far left beyond state 1 or far right beyond state 500. At each time step, the agent selects to move either left or right with equal probability. The environment determines how much the agent moves in the selected direction.</p>
<p><strong>In this assignment, you will:</strong> - Implement stochastic gradient descent method for state-value prediction. - Implement semi-gradient TD with a neural network as the function approximator and Adam algorithm. - Compare performance of semi-gradient TD with a neural network and semi-gradient TD with tile-coding.</p>
<h2 id="packages">Packages</h2>
<p>We import the following libraries that are required for this assignment:</p>
<ul>
<li><a href="www.numpy.org">numpy</a> : Fundamental package for scientific computing with Python.</li>
<li><a target="_blank" rel="noopener" href="http://matplotlib.org">matplotlib</a> : Library for plotting graphs in Python.</li>
<li><a target="_blank" rel="noopener" href="http://www.jmlr.org/papers/v10/tanner09a.html">RL-Glue</a> : Library for reinforcement learning experiments.</li>
<li><a target="_blank" rel="noopener" href="https://tqdm.github.io/">tqdm</a> : A package to display progress bar when running experiments.</li>
<li>BaseOptimizer : An abstract class that specifies the optimizer API for Agent.</li>
<li>plot_script : Custom script to plot results.</li>
<li>RandomWalkEnvironment : The Randomwalk environment script from Course 3 Assignment 1.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Do not modify this cell!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Import necessary libraries</span></span><br><span class="line"><span class="comment"># DO NOT IMPORT OTHER LIBRARIES - This will break the autograder.</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os, shutil</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rl_glue <span class="keyword">import</span> RLGlue</span><br><span class="line"><span class="keyword">from</span> environment <span class="keyword">import</span> BaseEnvironment</span><br><span class="line"><span class="keyword">from</span> agent <span class="keyword">import</span> BaseAgent</span><br><span class="line"><span class="keyword">from</span> optimizer <span class="keyword">import</span> BaseOptimizer</span><br><span class="line"><span class="keyword">import</span> plot_script</span><br><span class="line"><span class="keyword">from</span> randomwalk_environment <span class="keyword">import</span> RandomWalkEnvironment</span><br></pre></td></tr></table></figure>
<h2 id="section-1-create-semi-gradient-td-with-a-neural-network">Section 1: Create semi-gradient TD with a Neural Network</h2>
<p>In this section, you will implement an Agent that learns with semi-gradient TD with a neural network. You will use a neural network with one hidden layer. The input of the neural network is the one-hot encoding of the state number. We use the one-hot encoding of the state number instead of the state number itself because we do not want to build the prior knowledge that integer number inputs close to each other have similar values. The hidden layer contains 100 rectifier linear units (ReLUs) which pass their input if it is bigger than one and return 0 otherwise. ReLU gates are commonly used in neural networks due to their nice properties such as the sparsity of the activation and having non-vanishing gradients. The output of the neural network is the estimated state value. It is a linear function of the hidden units as is commonly the case when estimating the value of a continuous target using neural networks.</p>
<p>The neural network looks like this: <img src="nn_structure.png" /></p>
<p>For a given input, <span class="math inline">\(s\)</span>, value of <span class="math inline">\(s\)</span> is computed by: <span class="math display">\[
\begin{align} 
\psi &amp;= sW^{[0]} + b^{[0]} \\
x &amp;= \textit{max}(0, \psi) \\
v &amp;= xW^{[1]} + b^{[1]}
\end{align} 
\]</span></p>
<p>where <span class="math inline">\(W^{[0]}\)</span>, <span class="math inline">\(b^{[0]}\)</span>, <span class="math inline">\(W^{[1]}\)</span>, <span class="math inline">\(b^{[1]}\)</span> are the parameters of the network and will be learned when training the agent.</p>
<h2 id="implement-helper-methods">1-1: Implement helper methods</h2>
<p>Before implementing the agent, you first implement some helper functions which you will later use in agent's main methods.</p>
<h3 id="implement-get_value">Implement <code>get_value()</code></h3>
<p>First, you will implement get_value() method which feeds an input <span class="math inline">\(s\)</span> into the neural network and returns the output of the network <span class="math inline">\(v\)</span> according to the equations above. To implement get_value(), take into account the following notes:</p>
<ul>
<li><code>get_value()</code> gets the one-hot encoded state number denoted by s as an input.</li>
<li><code>get_value()</code> receives the weights of the neural network as input, denoted by weights and structured as an array of dictionaries. Each dictionary corresponds to weights from one layer of the neural network to the next. Each dictionary includes <span class="math inline">\(W\)</span> and <span class="math inline">\(b\)</span>. The shape of the elements in weights are as follows:
<ul>
<li>weights[0]["W"]: num_states <span class="math inline">\(\times\)</span> num_hidden_units</li>
<li>weights[0]["b"]: 1 <span class="math inline">\(\times\)</span> num_hidden_units</li>
<li>weights[1]["W"]: num_hidden_units <span class="math inline">\(\times\)</span> 1</li>
<li>weights[1]["b"]: 1 <span class="math inline">\(\times\)</span> 1</li>
</ul></li>
<li>The input of the neural network is a sparse vector. To make computation faster, we take advantage of input sparsity. To do so, we provided a helper method <code>my_matmul()</code>. <strong>Make sure that you use <code>my_matmul()</code> for all matrix multiplications except for element-wise multiplications in this notebook.</strong></li>
<li>The max operator used for computing <span class="math inline">\(x\)</span> is element-wise.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_matmul</span>(<span class="params">x1, x2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Given matrices x1 and x2, return the multiplication of them</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    result = np.zeros((x1.shape[<span class="number">0</span>], x2.shape[<span class="number">1</span>]))</span><br><span class="line">    x1_non_zero_indices = x1.nonzero()</span><br><span class="line">    <span class="keyword">if</span> x1.shape[<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">len</span>(x1_non_zero_indices[<span class="number">1</span>]) == <span class="number">1</span>:</span><br><span class="line">        result = x2[x1_non_zero_indices[<span class="number">1</span>], :]</span><br><span class="line">    <span class="keyword">elif</span> x1.shape[<span class="number">1</span>] == <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">len</span>(x1_non_zero_indices[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        result[x1_non_zero_indices[<span class="number">0</span>], :] = x2 * x1[x1_non_zero_indices[<span class="number">0</span>], <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = np.matmul(x1, x2)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># Graded Cell</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_value</span>(<span class="params">s, weights</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Compute value of input s given the weights of a neural network</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">### Compute the ouput of the neural network, v, for input s</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ----------------</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br><span class="line">    hidden = my_matmul(s, weights[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>]) + weights[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>]</span><br><span class="line">    x = np.maximum(hidden, np.zeros_like(hidden))</span><br><span class="line">    v = my_matmul(x, weights[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>]) + weights[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ----------------</span></span><br><span class="line">    <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure>
<p>Run the following code to test your implementation of the <code>get_value()</code> function:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># Tested Cell</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># The contents of the cell will be tested by the autograder.</span></span><br><span class="line"><span class="comment"># If they do not pass here, they will not pass there.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Suppose num_states = 5, num_hidden_layer = 1, and num_hidden_units = 10 </span></span><br><span class="line">num_hidden_layer = <span class="number">1</span></span><br><span class="line">s = np.array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">weights_data = np.load(<span class="string">&quot;asserts/get_value_weights.npz&quot;</span>)</span><br><span class="line">weights = [<span class="built_in">dict</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_hidden_layer+<span class="number">1</span>)]</span><br><span class="line">weights[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>] = weights_data[<span class="string">&quot;W0&quot;</span>]</span><br><span class="line">weights[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>] = weights_data[<span class="string">&quot;b0&quot;</span>]</span><br><span class="line">weights[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>] = weights_data[<span class="string">&quot;W1&quot;</span>]</span><br><span class="line">weights[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>] = weights_data[<span class="string">&quot;b1&quot;</span>]</span><br><span class="line"></span><br><span class="line">estimated_value = get_value(s, weights)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Estimated value: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(estimated_value))</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(np.allclose(estimated_value, [[-<span class="number">0.21915705</span>]]))</span><br></pre></td></tr></table></figure>
<pre><code>Estimated value: [[-0.21915705]]</code></pre>
<p><strong>Expected output</strong>:</p>
<pre><code>Estimated value: [[-0.21915705]]</code></pre>
<h3 id="implement-get_gradient">Implement <code>get_gradient()</code></h3>
<p>You will also implement <code>get_gradient()</code> method which computes the gradient of the value function for a given input, using backpropagation. You will later use this function to update the value function.</p>
<p>As you know, we compute the value of a state <span class="math inline">\(s\)</span> according to: <span class="math display">\[
\begin{align} 
\psi &amp;= sW^{[0]} + b^{[0]} \\
x &amp;= \textit{max}(0, \psi) \\
v &amp;= xW^{[1]} + b^{[1]}
\end{align} 
\]</span></p>
<p>To update the weights of the neural network (<span class="math inline">\(W^{[0]}\)</span>, <span class="math inline">\(b^{[0]}\)</span>, <span class="math inline">\(W^{[1]}\)</span>, <span class="math inline">\(b^{[1]}\)</span>), we compute the gradient of <span class="math inline">\(v\)</span> with respect to the weights according to:</p>
<p><span class="math display">\[
\begin{align} 
\frac{\partial v}{\partial W^{[0]}} &amp;= s^T(W^{[1]T} \odot I_{x&gt;0}) \\
\frac{\partial v}{\partial b^{[0]}} &amp;= W^{[1]T} \odot I_{x&gt;0} \\
\frac{\partial v}{\partial W^{[1]}} &amp;= x^T \\
\frac{\partial v}{\partial b^{[1]}} &amp;= 1
\end{align}
\]</span> where <span class="math inline">\(\odot\)</span> denotes element-wise matrix multiplication and <span class="math inline">\(I_{x&gt;0}\)</span> is the gradient of the ReLU activation function which is an indicator whose <span class="math inline">\(i\)</span>th element is 1 if <span class="math inline">\(x[i]&gt;0\)</span> and 0 otherwise.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># Graded Cell</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_gradient</span>(<span class="params">s, weights</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Given inputs s and weights, return the gradient of v with respect to the weights</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">### Compute the gradient of the value function with respect to W0, b0, W1, b1 for input s</span></span><br><span class="line">    <span class="comment"># grads[0][&quot;W&quot;] = ?</span></span><br><span class="line">    <span class="comment"># grads[0][&quot;b&quot;] = ?</span></span><br><span class="line">    <span class="comment"># grads[1][&quot;W&quot;] = ?</span></span><br><span class="line">    <span class="comment"># grads[1][&quot;b&quot;] = ?</span></span><br><span class="line">    <span class="comment"># Note that grads[0][&quot;W&quot;], grads[0][&quot;b&quot;], grads[1][&quot;W&quot;], and grads[1][&quot;b&quot;] should have the same shape as </span></span><br><span class="line">    <span class="comment"># weights[0][&quot;W&quot;], weights[0][&quot;b&quot;], weights[1][&quot;W&quot;], and weights[1][&quot;b&quot;] respectively</span></span><br><span class="line">    <span class="comment"># Note that to compute the gradients, you need to compute the activation of the hidden layer (x)</span></span><br><span class="line"></span><br><span class="line">    grads = [<span class="built_in">dict</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(weights))]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ----------------</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br><span class="line">    hidden = my_matmul(s, weights[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>]) + weights[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>]</span><br><span class="line">    x = np.maximum(hidden, np.zeros_like(hidden))</span><br><span class="line">    </span><br><span class="line">    grads[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>] = my_matmul(np.transpose(s),np.maximum(np.transpose(weights[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>]),<span class="number">0</span>))</span><br><span class="line">    grads[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>] = np.maximum(np.transpose(weights[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>]),<span class="number">0</span>)</span><br><span class="line">    grads[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>] = np.transpose(x)</span><br><span class="line">    grads[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># ----------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grads</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Run the following code to test your implementation of the <code>get_gradient()</code> function:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># Tested Cell</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># The contents of the cell will be tested by the autograder.</span></span><br><span class="line"><span class="comment"># If they do not pass here, they will not pass there.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Suppose num_states = 5, num_hidden_layer = 1, and num_hidden_units = 2 </span></span><br><span class="line">num_hidden_layer = <span class="number">1</span></span><br><span class="line">s = np.array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">weights_data = np.load(<span class="string">&quot;asserts/get_gradient_weights.npz&quot;</span>)</span><br><span class="line">weights = [<span class="built_in">dict</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_hidden_layer+<span class="number">1</span>)]</span><br><span class="line">weights[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>] = weights_data[<span class="string">&quot;W0&quot;</span>]</span><br><span class="line">weights[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>] = weights_data[<span class="string">&quot;b0&quot;</span>]</span><br><span class="line">weights[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>] = weights_data[<span class="string">&quot;W1&quot;</span>]</span><br><span class="line">weights[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>] = weights_data[<span class="string">&quot;b1&quot;</span>]</span><br><span class="line"></span><br><span class="line">grads = get_gradient(s, weights)</span><br><span class="line"></span><br><span class="line">grads_answer = np.load(<span class="string">&quot;asserts/get_gradient_grads.npz&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(np.allclose(grads[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>], grads_answer[<span class="string">&quot;W0&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(grads[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>], grads_answer[<span class="string">&quot;b0&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(grads[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>], grads_answer[<span class="string">&quot;W1&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(grads[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>], grads_answer[<span class="string">&quot;b1&quot;</span>]))</span><br></pre></td></tr></table></figure>
<p><strong>Expected output</strong>:</p>
<pre><code>grads[0][&quot;W&quot;]
 [[0.         0.        ]
 [0.         0.        ]
 [0.         0.        ]
 [0.76103773 0.12167502]
 [0.         0.        ]] 

grads[0][&quot;b&quot;]
 [[0.76103773 0.12167502]] 

grads[1][&quot;W&quot;]
 [[0.69198983]
 [0.82403662]] 

grads[1][&quot;b&quot;]
 [[1.]] </code></pre>
<h3 id="implement-stochastic-gradient-descent-method-for-state-value-prediction">Implement stochastic gradient descent method for state-value prediction</h3>
<p>In this section, you will implement stochastic gradient descent (SGD) method for state_value prediction. Here is the basic SGD update for state-value prediction with TD:</p>
<p><span class="math display">\[\mathbf{w_{t+1}} = \mathbf{w_{t}} + \alpha \delta_t \nabla \hat{v}(S_t,\mathbf{w_{t}})\]</span></p>
<p>At each time step, we update the weights in the direction <span class="math inline">\(g_t = \delta_t \nabla \hat{v}(S_t,\mathbf{w_t})\)</span> using a fixed step-size <span class="math inline">\(\alpha\)</span>. <span class="math inline">\(\delta_t = R_{t+1} + \gamma \hat{v}(S_{t+1},\mathbf{w_{t}}) - \hat{v}(S_t,\mathbf{w_t})\)</span> is the TD-error. <span class="math inline">\(\nabla \hat{v}(S_t,\mathbf{w_{t}})\)</span> is the gradient of the value function with respect to the weights.</p>
<p>The following cell includes the SGD class. You will complete the <code>update_weight()</code> method of SGD assuming that the weights and update g are provided.</p>
<p><strong>As you know, in this assignment, we structured the weights as an array of dictionaries. Note that the updates <span class="math inline">\(g_t\)</span>, in the case of TD, is <span class="math inline">\(\delta_t \nabla \hat{v}(S_t,\mathbf{w_t})\)</span>. As a result, <span class="math inline">\(g_t\)</span> has the same structure as <span class="math inline">\(\nabla \hat{v}(S_t,\mathbf{w_t})\)</span> which is also an array of dictionaries.</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># Graded Cell</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SGD</span>(<span class="params">BaseOptimizer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optimizer_init</span>(<span class="params">self, optimizer_info</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Setup for the optimizer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Set parameters needed to setup the stochastic gradient descent method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Assume optimizer_info dict contains:</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            step_size: float</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.step_size = optimizer_info.get(<span class="string">&quot;step_size&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_weights</span>(<span class="params">self, weights, g</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Given weights and update g, return updated weights</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(weights)):</span><br><span class="line">            <span class="keyword">for</span> param <span class="keyword">in</span> weights[i].keys():</span><br><span class="line">                </span><br><span class="line">                <span class="comment">### update weights</span></span><br><span class="line">                <span class="comment"># weights[i][param] = None</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># ----------------</span></span><br><span class="line">                <span class="comment"># your code here</span></span><br><span class="line">                weights[i][param] += self.step_size * g[i][param]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># ----------------</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure>
<p>Run the following code to test your implementation of the <code>update_weights()</code> function:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># Tested Cell</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># The contents of the cell will be tested by the autograder.</span></span><br><span class="line"><span class="comment"># If they do not pass here, they will not pass there.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Suppose num_states = 5, num_hidden_layer = 1, and num_hidden_units = 2 </span></span><br><span class="line">num_hidden_layer = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">weights_data = np.load(<span class="string">&quot;asserts/update_weights_weights.npz&quot;</span>)</span><br><span class="line">weights = [<span class="built_in">dict</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_hidden_layer+<span class="number">1</span>)]</span><br><span class="line">weights[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>] = weights_data[<span class="string">&quot;W0&quot;</span>]</span><br><span class="line">weights[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>] = weights_data[<span class="string">&quot;b0&quot;</span>]</span><br><span class="line">weights[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>] = weights_data[<span class="string">&quot;W1&quot;</span>]</span><br><span class="line">weights[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>] = weights_data[<span class="string">&quot;b1&quot;</span>]</span><br><span class="line"></span><br><span class="line">g_data = np.load(<span class="string">&quot;asserts/update_weights_g.npz&quot;</span>)</span><br><span class="line">g = [<span class="built_in">dict</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_hidden_layer+<span class="number">1</span>)]</span><br><span class="line">g[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>] = g_data[<span class="string">&quot;W0&quot;</span>]</span><br><span class="line">g[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>] = g_data[<span class="string">&quot;b0&quot;</span>]</span><br><span class="line">g[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>] = g_data[<span class="string">&quot;W1&quot;</span>]</span><br><span class="line">g[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>] = g_data[<span class="string">&quot;b1&quot;</span>]</span><br><span class="line"></span><br><span class="line">test_sgd = SGD()</span><br><span class="line">optimizer_info = &#123;<span class="string">&quot;step_size&quot;</span>: <span class="number">0.3</span>&#125;</span><br><span class="line">test_sgd.optimizer_init(optimizer_info)</span><br><span class="line">updated_weights = test_sgd.update_weights(weights, g)</span><br><span class="line"></span><br><span class="line"><span class="comment"># updated weights asserts</span></span><br><span class="line">updated_weights_answer = np.load(<span class="string">&quot;asserts/update_weights_updated_weights.npz&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(np.allclose(updated_weights[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>], updated_weights_answer[<span class="string">&quot;W0&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(updated_weights[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>], updated_weights_answer[<span class="string">&quot;b0&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(updated_weights[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>], updated_weights_answer[<span class="string">&quot;W1&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(updated_weights[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>], updated_weights_answer[<span class="string">&quot;b1&quot;</span>]))</span><br></pre></td></tr></table></figure>
<p><strong>Expected output</strong>:</p>
<pre><code>updated_weights[0][&quot;W&quot;]
 [[ 1.17899492  0.53656321]
 [ 0.58008221  1.47666572]
 [ 1.01909411 -1.10248056]
 [ 0.72490408  0.06828853]
 [-0.20609725  0.69034095]] 

updated_weights[0][&quot;b&quot;]
 [[-0.18484533  0.92844539]] 

updated_weights[1][&quot;W&quot;]
 [[0.70488257]
 [0.58150878]] 

updated_weights[1][&quot;b&quot;]
 [[0.88467086]] </code></pre>
<h3 id="adam-algorithm">Adam Algorithm</h3>
<p>In this assignment, instead of using SGD for updating the weights, we use a more advanced algorithm called Adam. The Adam algorithm improves the SGD update with two concepts: adaptive vector step-sizes and momentum. It keeps estimates of the mean and second moment of the updates, denoted by <span class="math inline">\(\mathbf{m}\)</span> and <span class="math inline">\(\mathbf{v}\)</span> respectively: <span class="math display">\[\mathbf{m_t} = \beta_m \mathbf{m_{t-1}} + (1 - \beta_m)g_t \\
\mathbf{v_t} = \beta_v \mathbf{v_{t-1}} + (1 - \beta_v)g^2_t
\]</span></p>
<p>Given that <span class="math inline">\(\mathbf{m}\)</span> and <span class="math inline">\(\mathbf{v}\)</span> are initialized to zero, they are biased toward zero. To get unbiased estimates of the mean and second moment, Adam defines <span class="math inline">\(\mathbf{\hat{m}}\)</span> and <span class="math inline">\(\mathbf{\hat{v}}\)</span> as: <span class="math display">\[ \mathbf{\hat{m_t}} = \frac{\mathbf{m_t}}{1 - \beta_m^t} \\
\mathbf{\hat{v_t}} = \frac{\mathbf{v_t}}{1 - \beta_v^t}
\]</span></p>
<p>The weights are then updated as follows: <span class="math display">\[ \mathbf{w_t} = \mathbf{w_{t-1}} + \frac{\alpha}{\sqrt{\mathbf{\hat{v_t}}}+\epsilon} \mathbf{\hat{m_t}}
\]</span></p>
<p>When implementing the agent you will use the Adam algorithm instead of SGD because it is more efficient. We have already provided you the implementation of the Adam algorithm in the cell below. You will use it when implementing your agent.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># Discussion Cell</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adam</span>(<span class="params">BaseOptimizer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optimizer_init</span>(<span class="params">self, optimizer_info</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Setup for the optimizer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Set parameters needed to setup the Adam algorithm.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Assume optimizer_info dict contains:</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            num_states: integer,</span></span><br><span class="line"><span class="string">            num_hidden_layer: integer,</span></span><br><span class="line"><span class="string">            num_hidden_units: integer,</span></span><br><span class="line"><span class="string">            step_size: float, </span></span><br><span class="line"><span class="string">            self.beta_m: float</span></span><br><span class="line"><span class="string">            self.beta_v: float</span></span><br><span class="line"><span class="string">            self.epsilon: float</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        self.num_states = optimizer_info.get(<span class="string">&quot;num_states&quot;</span>)</span><br><span class="line">        self.num_hidden_layer = optimizer_info.get(<span class="string">&quot;num_hidden_layer&quot;</span>)</span><br><span class="line">        self.num_hidden_units = optimizer_info.get(<span class="string">&quot;num_hidden_units&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Specify Adam algorithm&#x27;s hyper parameters</span></span><br><span class="line">        self.step_size = optimizer_info.get(<span class="string">&quot;step_size&quot;</span>)</span><br><span class="line">        self.beta_m = optimizer_info.get(<span class="string">&quot;beta_m&quot;</span>)</span><br><span class="line">        self.beta_v = optimizer_info.get(<span class="string">&quot;beta_v&quot;</span>)</span><br><span class="line">        self.epsilon = optimizer_info.get(<span class="string">&quot;epsilon&quot;</span>)</span><br><span class="line"></span><br><span class="line">        self.layer_size = np.array([self.num_states, self.num_hidden_units, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Initialize Adam algorithm&#x27;s m and v</span></span><br><span class="line">        self.m = [<span class="built_in">dict</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_hidden_layer+<span class="number">1</span>)]</span><br><span class="line">        self.v = [<span class="built_in">dict</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_hidden_layer+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_hidden_layer+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Initialize self.m[i][&quot;W&quot;], self.m[i][&quot;b&quot;], self.v[i][&quot;W&quot;], self.v[i][&quot;b&quot;] to zero</span></span><br><span class="line">            self.m[i][<span class="string">&quot;W&quot;</span>] = np.zeros((self.layer_size[i], self.layer_size[i+<span class="number">1</span>]))</span><br><span class="line">            self.m[i][<span class="string">&quot;b&quot;</span>] = np.zeros((<span class="number">1</span>, self.layer_size[i+<span class="number">1</span>]))</span><br><span class="line">            self.v[i][<span class="string">&quot;W&quot;</span>] = np.zeros((self.layer_size[i], self.layer_size[i+<span class="number">1</span>]))</span><br><span class="line">            self.v[i][<span class="string">&quot;b&quot;</span>] = np.zeros((<span class="number">1</span>, self.layer_size[i+<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Initialize beta_m_product and beta_v_product to be later used for computing m_hat and v_hat</span></span><br><span class="line">        self.beta_m_product = self.beta_m</span><br><span class="line">        self.beta_v_product = self.beta_v</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_weights</span>(<span class="params">self, weights, g</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Given weights and update g, return updated weights</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(weights)):</span><br><span class="line">            <span class="keyword">for</span> param <span class="keyword">in</span> weights[i].keys():</span><br><span class="line"></span><br><span class="line">                <span class="comment">### update self.m and self.v</span></span><br><span class="line">                self.m[i][param] = self.beta_m * self.m[i][param] + (<span class="number">1</span> - self.beta_m) * g[i][param]</span><br><span class="line">                self.v[i][param] = self.beta_v * self.v[i][param] + (<span class="number">1</span> - self.beta_v) * (g[i][param] * g[i][param])</span><br><span class="line"></span><br><span class="line">                <span class="comment">### compute m_hat and v_hat</span></span><br><span class="line">                m_hat = self.m[i][param] / (<span class="number">1</span> - self.beta_m_product)</span><br><span class="line">                v_hat = self.v[i][param] / (<span class="number">1</span> - self.beta_v_product)</span><br><span class="line"></span><br><span class="line">                <span class="comment">### update weights</span></span><br><span class="line">                weights[i][param] += self.step_size * m_hat / (np.sqrt(v_hat) + self.epsilon)</span><br><span class="line">                </span><br><span class="line">        <span class="comment">### update self.beta_m_product and self.beta_v_product</span></span><br><span class="line">        self.beta_m_product *= self.beta_m</span><br><span class="line">        self.beta_v_product *= self.beta_v</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> weights</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="implement-agent-methods">1-2: Implement Agent Methods</h2>
<p>In this section, you will implement <code>agent_init()</code>, <code>agent_start()</code>, <code>agent_step()</code>, and <code>agent_end()</code>.</p>
<p>In <code>agent_init()</code>, you will:</p>
<ul>
<li>specify the neural network structure by filling self.layer_size with the size of the input layer, hidden layer, and output layer.</li>
<li>initialize the network's parameters. We show the parameters as an array of dictionaries, self.weights, where each dictionary corresponds to weights from one layer to the next. Each dictionary includes <span class="math inline">\(W\)</span> and <span class="math inline">\(b\)</span>.</li>
</ul>
<p><span class="math display">\[\sqrt{ \frac{2}{ input \, of \, each \, node } }\]</span></p>
<p>This initialization heuristic is commonly used when using ReLU gates and helps keep the output of a neuron from getting too big or too small. To initialize the network's parameters, use <strong>self.rand_generator.normal()</strong> which draws random samples from a normal distribution. The parameters of self.rand_generator.normal are mean of the distribution, standard deviation of the distribution, and output shape in the form of tuple of integers.</p>
<p>In <code>agent_start()</code>, you will: - specify self.last_state and self.last_action.</p>
<p>In <code>agent_step()</code> and <code>agent_end()</code>, you will: - compute the TD error using <span class="math inline">\(v(S_t)\)</span> and <span class="math inline">\(v(S_{t+1})\)</span>. To compute the value function for <span class="math inline">\(S_t\)</span> and <span class="math inline">\(S_{t+1}\)</span>, you will get their one-hot encoding using <code>one_hot()</code> method that we provided below. You feed the one-hot encoded state number to the neural networks using <code>get_value()</code> method that you implemented above. Note that <code>one_hot()</code> method returns the one-hot encoding of a state as a numpy array of shape (1, num_states). - retrieve the gradients using <code>get_gradient()</code> function that you implemented. - use Adam_algorithm that we provided to update the neural network's parameters, self.weights. - use <code>agent_policy()</code> method to select actions with. (only in <code>agent_step()</code>)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># Discussion Cell</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_hot</span>(<span class="params">state, num_states</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Given num_state and a state, return the one-hot encoding of the state</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Create the one-hot encoding of state</span></span><br><span class="line">    <span class="comment"># one_hot_vector is a numpy array of shape (1, num_states)</span></span><br><span class="line">    </span><br><span class="line">    one_hot_vector = np.zeros((<span class="number">1</span>, num_states))</span><br><span class="line">    one_hot_vector[<span class="number">0</span>, <span class="built_in">int</span>((state - <span class="number">1</span>))] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> one_hot_vector</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># Graded Cell</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TDAgent</span>(<span class="params">BaseAgent</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;td_agent&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">agent_init</span>(<span class="params">self, agent_info=&#123;&#125;</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Setup for the agent called when the experiment first starts.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Set parameters needed to setup the semi-gradient TD with a Neural Network.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Assume agent_info dict contains:</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            num_states: integer,</span></span><br><span class="line"><span class="string">            num_hidden_layer: integer,</span></span><br><span class="line"><span class="string">            num_hidden_units: integer,</span></span><br><span class="line"><span class="string">            step_size: float, </span></span><br><span class="line"><span class="string">            discount_factor: float,</span></span><br><span class="line"><span class="string">            self.beta_m: float</span></span><br><span class="line"><span class="string">            self.beta_v: float</span></span><br><span class="line"><span class="string">            self.epsilon: float</span></span><br><span class="line"><span class="string">            seed: int</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># Set random seed for weights initialization for each run</span></span><br><span class="line">        self.rand_generator = np.random.RandomState(agent_info.get(<span class="string">&quot;seed&quot;</span>)) </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Set random seed for policy for each run</span></span><br><span class="line">        self.policy_rand_generator = np.random.RandomState(agent_info.get(<span class="string">&quot;seed&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set attributes according to agent_info</span></span><br><span class="line">        self.num_states = agent_info.get(<span class="string">&quot;num_states&quot;</span>)</span><br><span class="line">        self.num_hidden_layer = agent_info.get(<span class="string">&quot;num_hidden_layer&quot;</span>)</span><br><span class="line">        self.num_hidden_units = agent_info.get(<span class="string">&quot;num_hidden_units&quot;</span>)</span><br><span class="line">        self.discount_factor = agent_info.get(<span class="string">&quot;discount_factor&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">### Define the neural network&#x27;s structure</span></span><br><span class="line">        <span class="comment"># Specify self.layer_size which shows the number of nodes in each layer</span></span><br><span class="line">        <span class="comment"># self.layer_size = np.array([None, None, None])</span></span><br><span class="line">        <span class="comment"># Hint: Checkout the NN diagram at the beginning of the notebook</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line">        <span class="comment"># your code here</span></span><br><span class="line">        self.layer_size = np.array([self.num_states, self.num_hidden_units, <span class="number">1</span>])</span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Initialize the neural network&#x27;s parameter</span></span><br><span class="line">        self.weights = [<span class="built_in">dict</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_hidden_layer+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_hidden_layer+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            <span class="comment">### Initialize self.weights[i][&quot;W&quot;] and self.weights[i][&quot;b&quot;] using self.rand_generator.normal()</span></span><br><span class="line">            <span class="comment"># Note that The parameters of self.rand_generator.normal are mean of the distribution, </span></span><br><span class="line">            <span class="comment"># standard deviation of the distribution, and output shape in the form of tuple of integers.</span></span><br><span class="line">            <span class="comment"># To specify output shape, use self.layer_size.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># ----------------</span></span><br><span class="line">            <span class="comment"># your code here</span></span><br><span class="line">            self.weights[i][<span class="string">&quot;W&quot;</span>] = self.rand_generator.normal(loc=<span class="number">0</span>, scale= np.sqrt(<span class="number">2.0</span> / self.layer_size[i]) ,size = (self.layer_size[i],self.layer_size[i+<span class="number">1</span>]))</span><br><span class="line">            self.weights[i][<span class="string">&quot;b&quot;</span>] = self.rand_generator.normal(loc=<span class="number">0</span>, scale= np.sqrt(<span class="number">2.0</span> / self.layer_size[i]) ,size = (<span class="number">1</span>,self.layer_size[i+<span class="number">1</span>]))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># ----------------</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Specify the optimizer</span></span><br><span class="line">        self.optimizer = Adam()</span><br><span class="line">        self.optimizer.optimizer_init(&#123;</span><br><span class="line">            <span class="string">&quot;num_states&quot;</span>: agent_info[<span class="string">&quot;num_states&quot;</span>],</span><br><span class="line">            <span class="string">&quot;num_hidden_layer&quot;</span>: agent_info[<span class="string">&quot;num_hidden_layer&quot;</span>],</span><br><span class="line">            <span class="string">&quot;num_hidden_units&quot;</span>: agent_info[<span class="string">&quot;num_hidden_units&quot;</span>],</span><br><span class="line">            <span class="string">&quot;step_size&quot;</span>: agent_info[<span class="string">&quot;step_size&quot;</span>],</span><br><span class="line">            <span class="string">&quot;beta_m&quot;</span>: agent_info[<span class="string">&quot;beta_m&quot;</span>],</span><br><span class="line">            <span class="string">&quot;beta_v&quot;</span>: agent_info[<span class="string">&quot;beta_v&quot;</span>],</span><br><span class="line">            <span class="string">&quot;epsilon&quot;</span>: agent_info[<span class="string">&quot;epsilon&quot;</span>],</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        self.last_state = <span class="literal">None</span></span><br><span class="line">        self.last_action = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">agent_policy</span>(<span class="params">self, state</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">### Set chosen_action as 0 or 1 with equal probability. </span></span><br><span class="line">        chosen_action = self.policy_rand_generator.choice([<span class="number">0</span>,<span class="number">1</span>])    </span><br><span class="line">        <span class="keyword">return</span> chosen_action</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">agent_start</span>(<span class="params">self, state</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;The first method called when the experiment starts, called after</span></span><br><span class="line"><span class="string">        the environment starts.</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            state (Numpy array): the state from the</span></span><br><span class="line"><span class="string">                environment&#x27;s evn_start function.</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            The first action the agent takes.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">### select action given state (using self.agent_policy()), and save current state and action</span></span><br><span class="line">        <span class="comment"># self.last_state = ?</span></span><br><span class="line">        <span class="comment"># self.last_action = ?</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line">        <span class="comment"># your code here</span></span><br><span class="line">        self.last_action = self.agent_policy(state)</span><br><span class="line">        self.last_state = state</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.last_action</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">agent_step</span>(<span class="params">self, reward, state</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;A step taken by the agent.</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            reward (float): the reward received for taking the last action taken</span></span><br><span class="line"><span class="string">            state (Numpy array): the state from the</span></span><br><span class="line"><span class="string">                environment&#x27;s step based, where the agent ended up after the</span></span><br><span class="line"><span class="string">                last step</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            The action the agent is taking.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        last_state_vec = one_hot(self.last_state, self.num_states)</span><br><span class="line">        last_value = get_value(last_state_vec, self.weights)</span><br><span class="line"></span><br><span class="line">        state_vec = one_hot(state, self.num_states)</span><br><span class="line">        value = get_value(state_vec, self.weights)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">### Compute TD error</span></span><br><span class="line">        <span class="comment"># delta = None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line">        <span class="comment"># your code here</span></span><br><span class="line">        delta = reward + self.discount_factor * value - last_value</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">### Retrieve gradients</span></span><br><span class="line">        <span class="comment"># grads = None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line">        <span class="comment"># your code here</span></span><br><span class="line">        grads = get_gradient(last_state_vec, self.weights)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">### Compute g (1 line)</span></span><br><span class="line">        g = [<span class="built_in">dict</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_hidden_layer+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_hidden_layer+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> param <span class="keyword">in</span> self.weights[i].keys():</span><br><span class="line"></span><br><span class="line">                <span class="comment"># g[i][param] = None</span></span><br><span class="line">                <span class="comment"># ----------------</span></span><br><span class="line">                <span class="comment"># your code here</span></span><br><span class="line">                g[i][param] = grads[i][param] * delta</span><br><span class="line">                <span class="comment"># ----------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">### update the weights using self.optimizer</span></span><br><span class="line">        <span class="comment"># self.weights = None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line">        <span class="comment"># your code here</span></span><br><span class="line">        self.optimizer.update_weights(self.weights, g)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">### update self.last_state and self.last_action</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line">        <span class="comment"># your code here</span></span><br><span class="line">        self.last_action = self.agent_policy(state)</span><br><span class="line">        self.last_state = state</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.last_action</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">agent_end</span>(<span class="params">self, reward</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run when the agent terminates.</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            reward (float): the reward the agent received for entering the</span></span><br><span class="line"><span class="string">                terminal state.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        last_state_vec = one_hot(self.last_state, self.num_states)</span><br><span class="line">        last_value = get_value(last_state_vec, self.weights)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">### compute TD error</span></span><br><span class="line">        <span class="comment"># delta = None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line">        <span class="comment"># your code here</span></span><br><span class="line">        delta = reward - last_value</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">### Retrieve gradients</span></span><br><span class="line">        <span class="comment"># grads = None</span></span><br><span class="line">        grads = get_gradient(last_state_vec, self.weights)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line">        <span class="comment"># your code here</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">### Compute g</span></span><br><span class="line">        g = [<span class="built_in">dict</span>() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_hidden_layer+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_hidden_layer+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> param <span class="keyword">in</span> self.weights[i].keys():</span><br><span class="line"></span><br><span class="line">                <span class="comment"># g[i][param] = None</span></span><br><span class="line">                <span class="comment"># ----------------</span></span><br><span class="line">                <span class="comment"># your code here</span></span><br><span class="line">                g[i][param] = grads[i][param] * delta</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># ----------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">### update the weights using self.optimizer</span></span><br><span class="line">        <span class="comment"># self.weights = None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line">        <span class="comment"># your code here</span></span><br><span class="line">        self.optimizer.update_weights(self.weights, g)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ----------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">agent_message</span>(<span class="params">self, message</span>):</span></span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">&#x27;get state value&#x27;</span>:</span><br><span class="line">            state_value = np.zeros(self.num_states)</span><br><span class="line">            <span class="keyword">for</span> state <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, self.num_states + <span class="number">1</span>):</span><br><span class="line">                s = one_hot(state, self.num_states)</span><br><span class="line">                state_value[state - <span class="number">1</span>] = get_value(s, self.weights)</span><br><span class="line">            <span class="keyword">return</span> state_value</span><br></pre></td></tr></table></figure>
<p>Run the following code to test your implementation of the <code>agent_init()</code> function:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># Tested Cell</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># The contents of the cell will be tested by the autograder.</span></span><br><span class="line"><span class="comment"># If they do not pass here, they will not pass there.</span></span><br><span class="line"></span><br><span class="line">agent_info = &#123;</span><br><span class="line">    <span class="string">&quot;num_states&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;num_hidden_layer&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;num_hidden_units&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;step_size&quot;</span>: <span class="number">0.25</span>,</span><br><span class="line">    <span class="string">&quot;discount_factor&quot;</span>: <span class="number">0.9</span>,</span><br><span class="line">    <span class="string">&quot;beta_m&quot;</span>: <span class="number">0.9</span>,</span><br><span class="line">    <span class="string">&quot;beta_v&quot;</span>: <span class="number">0.99</span>,</span><br><span class="line">    <span class="string">&quot;epsilon&quot;</span>: <span class="number">0.0001</span>,</span><br><span class="line">    <span class="string">&quot;seed&quot;</span>: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_agent = TDAgent()</span><br><span class="line">test_agent.agent_init(agent_info)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;layer_size: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(test_agent.layer_size))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(test_agent.layer_size, np.array([agent_info[<span class="string">&quot;num_states&quot;</span>], </span><br><span class="line">                                                    agent_info[<span class="string">&quot;num_hidden_units&quot;</span>], </span><br><span class="line">                                                    <span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(test_agent.weights[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>].shape == (agent_info[<span class="string">&quot;num_states&quot;</span>], agent_info[<span class="string">&quot;num_hidden_units&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(test_agent.weights[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>].shape == (<span class="number">1</span>, agent_info[<span class="string">&quot;num_hidden_units&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(test_agent.weights[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>].shape == (agent_info[<span class="string">&quot;num_hidden_units&quot;</span>], <span class="number">1</span>))</span><br><span class="line"><span class="keyword">assert</span>(test_agent.weights[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>].shape == (<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">agent_weight_answer = np.load(<span class="string">&quot;asserts/agent_init_weights_1.npz&quot;</span>)</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(test_agent.weights[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>], agent_weight_answer[<span class="string">&quot;W0&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(test_agent.weights[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>], agent_weight_answer[<span class="string">&quot;b0&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(test_agent.weights[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>], agent_weight_answer[<span class="string">&quot;W1&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(test_agent.weights[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>], agent_weight_answer[<span class="string">&quot;b1&quot;</span>]))</span><br></pre></td></tr></table></figure>
<pre><code>layer_size: [5 2 1]</code></pre>
<p><strong>Expected output</strong>:</p>
<pre><code>layer_size: [5 2 1]
weights[0][&quot;W&quot;] shape: (5, 2)
weights[0][&quot;b&quot;] shape: (1, 2)
weights[1][&quot;W&quot;] shape: (2, 1)
weights[1][&quot;b&quot;] shape: (1, 1) 

weights[0][&quot;W&quot;]
 [[ 1.11568467  0.25308164]
 [ 0.61900825  1.4172653 ]
 [ 1.18114738 -0.6180848 ]
 [ 0.60088868 -0.0957267 ]
 [-0.06528133  0.25968529]] 

weights[0][&quot;b&quot;]
 [[0.09110115 0.91976332]] 

weights[1][&quot;W&quot;]
 [[0.76103773]
 [0.12167502]] 

weights[1][&quot;b&quot;]
 [[0.44386323]]</code></pre>
<p>Run the following code to test your implementation of the <code>agent_start()</code> function:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># Tested Cell</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># The contents of the cell will be tested by the autograder.</span></span><br><span class="line"><span class="comment"># If they do not pass here, they will not pass there.</span></span><br><span class="line"></span><br><span class="line">agent_info = &#123;</span><br><span class="line">    <span class="string">&quot;num_states&quot;</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="string">&quot;num_hidden_layer&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;num_hidden_units&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">&quot;step_size&quot;</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">&quot;discount_factor&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">    <span class="string">&quot;beta_m&quot;</span>: <span class="number">0.9</span>,</span><br><span class="line">    <span class="string">&quot;beta_v&quot;</span>: <span class="number">0.99</span>,</span><br><span class="line">    <span class="string">&quot;epsilon&quot;</span>: <span class="number">0.0001</span>,</span><br><span class="line">    <span class="string">&quot;seed&quot;</span>: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Suppose state = 250</span></span><br><span class="line">state = <span class="number">250</span></span><br><span class="line"></span><br><span class="line">test_agent = TDAgent()</span><br><span class="line">test_agent.agent_init(agent_info)</span><br><span class="line">test_agent.agent_start(state)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(test_agent.last_state == <span class="number">250</span>)</span><br><span class="line"><span class="keyword">assert</span>(test_agent.last_action == <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Expected output</strong>:</p>
<pre><code>Agent state: 250
Agent selected action: 1</code></pre>
<p>Run the following code to test your implementation of the <code>agent_step()</code> function:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># Tested Cell</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># The contents of the cell will be tested by the autograder.</span></span><br><span class="line"><span class="comment"># If they do not pass here, they will not pass there.</span></span><br><span class="line"></span><br><span class="line">agent_info = &#123;</span><br><span class="line">    <span class="string">&quot;num_states&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;num_hidden_layer&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;num_hidden_units&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;step_size&quot;</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">&quot;discount_factor&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">    <span class="string">&quot;beta_m&quot;</span>: <span class="number">0.9</span>,</span><br><span class="line">    <span class="string">&quot;beta_v&quot;</span>: <span class="number">0.99</span>,</span><br><span class="line">    <span class="string">&quot;epsilon&quot;</span>: <span class="number">0.0001</span>,</span><br><span class="line">    <span class="string">&quot;seed&quot;</span>: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_agent = TDAgent()</span><br><span class="line">test_agent.agent_init(agent_info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># load initial weights</span></span><br><span class="line">agent_initial_weight = np.load(<span class="string">&quot;asserts/agent_step_initial_weights.npz&quot;</span>)</span><br><span class="line">test_agent.weights[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>] = agent_initial_weight[<span class="string">&quot;W0&quot;</span>]</span><br><span class="line">test_agent.weights[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>] = agent_initial_weight[<span class="string">&quot;b0&quot;</span>]</span><br><span class="line">test_agent.weights[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>] = agent_initial_weight[<span class="string">&quot;W1&quot;</span>]</span><br><span class="line">test_agent.weights[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>] = agent_initial_weight[<span class="string">&quot;b1&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># load m and v for the optimizer</span></span><br><span class="line">m_data = np.load(<span class="string">&quot;asserts/agent_step_initial_m.npz&quot;</span>)</span><br><span class="line">test_agent.optimizer.m[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>] = m_data[<span class="string">&quot;W0&quot;</span>]</span><br><span class="line">test_agent.optimizer.m[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>] = m_data[<span class="string">&quot;b0&quot;</span>]</span><br><span class="line">test_agent.optimizer.m[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>] = m_data[<span class="string">&quot;W1&quot;</span>]</span><br><span class="line">test_agent.optimizer.m[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>] = m_data[<span class="string">&quot;b1&quot;</span>]</span><br><span class="line"></span><br><span class="line">v_data = np.load(<span class="string">&quot;asserts/agent_step_initial_v.npz&quot;</span>)</span><br><span class="line">test_agent.optimizer.v[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>] = v_data[<span class="string">&quot;W0&quot;</span>]</span><br><span class="line">test_agent.optimizer.v[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>] = v_data[<span class="string">&quot;b0&quot;</span>]</span><br><span class="line">test_agent.optimizer.v[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>] = v_data[<span class="string">&quot;W1&quot;</span>]</span><br><span class="line">test_agent.optimizer.v[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>] = v_data[<span class="string">&quot;b1&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume the agent started at State 3</span></span><br><span class="line">start_state = <span class="number">3</span></span><br><span class="line">test_agent.agent_start(start_state)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume the reward was 10.0 and the next state observed was State 1</span></span><br><span class="line">reward = <span class="number">10.0</span></span><br><span class="line">next_state = <span class="number">1</span></span><br><span class="line">test_agent.agent_step(reward, next_state)</span><br><span class="line"></span><br><span class="line">agent_updated_weight_answer = np.load(<span class="string">&quot;asserts/agent_step_updated_weights.npz&quot;</span>)</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(test_agent.weights[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>], agent_updated_weight_answer[<span class="string">&quot;W0&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(test_agent.weights[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>], agent_updated_weight_answer[<span class="string">&quot;b0&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(test_agent.weights[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>], agent_updated_weight_answer[<span class="string">&quot;W1&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(test_agent.weights[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>], agent_updated_weight_answer[<span class="string">&quot;b1&quot;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(test_agent.last_state == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">assert</span>(test_agent.last_action == <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Expected output</strong>:</p>
<pre><code>updated_weights[0][&quot;W&quot;]
 [[ 1.10893459  0.30763738]
 [ 0.63690565  1.14778865]
 [ 1.23397791 -0.48152743]
 [ 0.72792093 -0.15829832]
 [ 0.15021996  0.39822163]] 

updated_weights[0][&quot;b&quot;]
 [[0.29798822 0.96254535]] 

updated_weights[1][&quot;W&quot;]
 [[0.76628754]
 [0.11486511]] 

updated_weights[1][&quot;b&quot;]
 [[0.58530057]] 

Agent last state: 1
Agent last action: 1 </code></pre>
<p>Run the following code to test your implementation of the <code>agent_end()</code> function:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># Tested Cell</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># The contents of the cell will be tested by the autograder.</span></span><br><span class="line"><span class="comment"># If they do not pass here, they will not pass there.</span></span><br><span class="line"></span><br><span class="line">agent_info = &#123;</span><br><span class="line">    <span class="string">&quot;num_states&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;num_hidden_layer&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;num_hidden_units&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;step_size&quot;</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">&quot;discount_factor&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">    <span class="string">&quot;beta_m&quot;</span>: <span class="number">0.9</span>,</span><br><span class="line">    <span class="string">&quot;beta_v&quot;</span>: <span class="number">0.99</span>,</span><br><span class="line">    <span class="string">&quot;epsilon&quot;</span>: <span class="number">0.0001</span>,</span><br><span class="line">    <span class="string">&quot;seed&quot;</span>: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_agent = TDAgent()</span><br><span class="line">test_agent.agent_init(agent_info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># load initial weights</span></span><br><span class="line">agent_initial_weight = np.load(<span class="string">&quot;asserts/agent_end_initial_weights.npz&quot;</span>)</span><br><span class="line">test_agent.weights[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>] = agent_initial_weight[<span class="string">&quot;W0&quot;</span>]</span><br><span class="line">test_agent.weights[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>] = agent_initial_weight[<span class="string">&quot;b0&quot;</span>]</span><br><span class="line">test_agent.weights[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>] = agent_initial_weight[<span class="string">&quot;W1&quot;</span>]</span><br><span class="line">test_agent.weights[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>] = agent_initial_weight[<span class="string">&quot;b1&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># load m and v for the optimizer</span></span><br><span class="line">m_data = np.load(<span class="string">&quot;asserts/agent_step_initial_m.npz&quot;</span>)</span><br><span class="line">test_agent.optimizer.m[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>] = m_data[<span class="string">&quot;W0&quot;</span>]</span><br><span class="line">test_agent.optimizer.m[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>] = m_data[<span class="string">&quot;b0&quot;</span>]</span><br><span class="line">test_agent.optimizer.m[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>] = m_data[<span class="string">&quot;W1&quot;</span>]</span><br><span class="line">test_agent.optimizer.m[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>] = m_data[<span class="string">&quot;b1&quot;</span>]</span><br><span class="line"></span><br><span class="line">v_data = np.load(<span class="string">&quot;asserts/agent_step_initial_v.npz&quot;</span>)</span><br><span class="line">test_agent.optimizer.v[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>] = v_data[<span class="string">&quot;W0&quot;</span>]</span><br><span class="line">test_agent.optimizer.v[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>] = v_data[<span class="string">&quot;b0&quot;</span>]</span><br><span class="line">test_agent.optimizer.v[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>] = v_data[<span class="string">&quot;W1&quot;</span>]</span><br><span class="line">test_agent.optimizer.v[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>] = v_data[<span class="string">&quot;b1&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume the agent started at State 4</span></span><br><span class="line">start_state = <span class="number">4</span></span><br><span class="line">test_agent.agent_start(start_state)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assume the reward was 10.0 and reached the terminal state</span></span><br><span class="line">reward = <span class="number">10.0</span></span><br><span class="line">test_agent.agent_end(reward)</span><br><span class="line"></span><br><span class="line"><span class="comment"># updated weights asserts</span></span><br><span class="line">agent_updated_weight_answer = np.load(<span class="string">&quot;asserts/agent_end_updated_weights.npz&quot;</span>)</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(test_agent.weights[<span class="number">0</span>][<span class="string">&quot;W&quot;</span>], agent_updated_weight_answer[<span class="string">&quot;W0&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(test_agent.weights[<span class="number">0</span>][<span class="string">&quot;b&quot;</span>], agent_updated_weight_answer[<span class="string">&quot;b0&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(test_agent.weights[<span class="number">1</span>][<span class="string">&quot;W&quot;</span>], agent_updated_weight_answer[<span class="string">&quot;W1&quot;</span>]))</span><br><span class="line"><span class="keyword">assert</span>(np.allclose(test_agent.weights[<span class="number">1</span>][<span class="string">&quot;b&quot;</span>], agent_updated_weight_answer[<span class="string">&quot;b1&quot;</span>]))</span><br></pre></td></tr></table></figure>
<p><strong>Expected output:</strong></p>
<pre><code>updated_weights[0][&quot;W&quot;]
 [[ 1.10893459  0.30763738]
 [ 0.63690565  1.14778865]
 [ 1.17531054 -0.51043162]
 [ 0.75062903 -0.13736817]
 [ 0.15021996  0.39822163]] 

updated_weights[0][&quot;b&quot;]
 [[0.30846523 0.95937346]] 

updated_weights[1][&quot;W&quot;]
 [[0.68861703]
 [0.15986364]] 

updated_weights[1][&quot;b&quot;]
 [[0.586074]] </code></pre>
<h2 id="section-2---run-experiment">Section 2 - Run Experiment</h2>
<p>Now that you implemented the agent, we can run the experiment. Similar to Course 3 Programming Assignment 1, we will plot the learned state value function and the learning curve of the TD agent. To plot the learning curve, we use Root Mean Squared Value Error (RMSVE).</p>
<h2 id="run-experiment-for-semi-gradient-td-with-a-neural-network">2-1: Run Experiment for Semi-gradient TD with a Neural Network</h2>
<p>We have already provided you the experiment/plot code, so you can go ahead and run the two cells below.</p>
<p>Note that running the cell below will take <strong>approximately 12 minutes</strong>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"><span class="comment"># Discussion Cell</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line"></span><br><span class="line">true_state_val = np.load(<span class="string">&#x27;data/true_V.npy&#x27;</span>)    </span><br><span class="line">state_distribution = np.load(<span class="string">&#x27;data/state_distribution.npy&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_RMSVE</span>(<span class="params">learned_state_val</span>):</span></span><br><span class="line">    <span class="keyword">assert</span>(<span class="built_in">len</span>(true_state_val) == <span class="built_in">len</span>(learned_state_val) == <span class="built_in">len</span>(state_distribution))</span><br><span class="line">    MSVE = np.<span class="built_in">sum</span>(np.multiply(state_distribution, np.square(true_state_val - learned_state_val)))</span><br><span class="line">    RMSVE = np.sqrt(MSVE)</span><br><span class="line">    <span class="keyword">return</span> RMSVE</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define function to run experiment</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_experiment</span>(<span class="params">environment, agent, environment_parameters, agent_parameters, experiment_parameters</span>):</span></span><br><span class="line">    </span><br><span class="line">    rl_glue = RLGlue(environment, agent)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># save rmsve at the end of each episode</span></span><br><span class="line">    agent_rmsve = np.zeros((experiment_parameters[<span class="string">&quot;num_runs&quot;</span>], </span><br><span class="line">                            <span class="built_in">int</span>(experiment_parameters[<span class="string">&quot;num_episodes&quot;</span>]/experiment_parameters[<span class="string">&quot;episode_eval_frequency&quot;</span>]) + <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># save learned state value at the end of each run</span></span><br><span class="line">    agent_state_val = np.zeros((experiment_parameters[<span class="string">&quot;num_runs&quot;</span>], </span><br><span class="line">                                environment_parameters[<span class="string">&quot;num_states&quot;</span>]))</span><br><span class="line"></span><br><span class="line">    env_info = &#123;<span class="string">&quot;num_states&quot;</span>: environment_parameters[<span class="string">&quot;num_states&quot;</span>],</span><br><span class="line">                <span class="string">&quot;start_state&quot;</span>: environment_parameters[<span class="string">&quot;start_state&quot;</span>],</span><br><span class="line">                <span class="string">&quot;left_terminal_state&quot;</span>: environment_parameters[<span class="string">&quot;left_terminal_state&quot;</span>],</span><br><span class="line">                <span class="string">&quot;right_terminal_state&quot;</span>: environment_parameters[<span class="string">&quot;right_terminal_state&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">    agent_info = &#123;<span class="string">&quot;num_states&quot;</span>: environment_parameters[<span class="string">&quot;num_states&quot;</span>],</span><br><span class="line">                  <span class="string">&quot;num_hidden_layer&quot;</span>: agent_parameters[<span class="string">&quot;num_hidden_layer&quot;</span>],</span><br><span class="line">                  <span class="string">&quot;num_hidden_units&quot;</span>: agent_parameters[<span class="string">&quot;num_hidden_units&quot;</span>],</span><br><span class="line">                  <span class="string">&quot;step_size&quot;</span>: agent_parameters[<span class="string">&quot;step_size&quot;</span>],</span><br><span class="line">                  <span class="string">&quot;discount_factor&quot;</span>: environment_parameters[<span class="string">&quot;discount_factor&quot;</span>],</span><br><span class="line">                  <span class="string">&quot;beta_m&quot;</span>: agent_parameters[<span class="string">&quot;beta_m&quot;</span>],</span><br><span class="line">                  <span class="string">&quot;beta_v&quot;</span>: agent_parameters[<span class="string">&quot;beta_v&quot;</span>],</span><br><span class="line">                  <span class="string">&quot;epsilon&quot;</span>: agent_parameters[<span class="string">&quot;epsilon&quot;</span>]</span><br><span class="line">                 &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Setting - Neural Network with 100 hidden units&#x27;</span>)</span><br><span class="line">    os.system(<span class="string">&#x27;sleep 1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># one agent setting</span></span><br><span class="line">    <span class="keyword">for</span> run <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="number">1</span>, experiment_parameters[<span class="string">&quot;num_runs&quot;</span>]+<span class="number">1</span>)):</span><br><span class="line">        env_info[<span class="string">&quot;seed&quot;</span>] = run</span><br><span class="line">        agent_info[<span class="string">&quot;seed&quot;</span>] = run</span><br><span class="line">        rl_glue.rl_init(agent_info, env_info)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Compute initial RMSVE before training</span></span><br><span class="line">        current_V = rl_glue.rl_agent_message(<span class="string">&quot;get state value&quot;</span>)</span><br><span class="line">        agent_rmsve[run-<span class="number">1</span>, <span class="number">0</span>] = calc_RMSVE(current_V)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> episode <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, experiment_parameters[<span class="string">&quot;num_episodes&quot;</span>]+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># run episode</span></span><br><span class="line">            rl_glue.rl_episode(<span class="number">0</span>) <span class="comment"># no step limit</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> episode % experiment_parameters[<span class="string">&quot;episode_eval_frequency&quot;</span>] == <span class="number">0</span>:</span><br><span class="line">                current_V = rl_glue.rl_agent_message(<span class="string">&quot;get state value&quot;</span>)</span><br><span class="line">                agent_rmsve[run-<span class="number">1</span>, <span class="built_in">int</span>(episode/experiment_parameters[<span class="string">&quot;episode_eval_frequency&quot;</span>])] = calc_RMSVE(current_V)</span><br><span class="line">            <span class="keyword">elif</span> episode == experiment_parameters[<span class="string">&quot;num_episodes&quot;</span>]: <span class="comment"># if last episode</span></span><br><span class="line">                current_V = rl_glue.rl_agent_message(<span class="string">&quot;get state value&quot;</span>)</span><br><span class="line"></span><br><span class="line">        agent_state_val[run-<span class="number">1</span>, :] = current_V</span><br><span class="line"></span><br><span class="line">    save_name = <span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(rl_glue.agent.name).replace(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;results&#x27;</span>):</span><br><span class="line">                os.makedirs(<span class="string">&#x27;results&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># save avg. state value</span></span><br><span class="line">    np.save(<span class="string">&quot;results/V_&#123;&#125;&quot;</span>.<span class="built_in">format</span>(save_name), agent_state_val)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># save avg. rmsve</span></span><br><span class="line">    np.savez(<span class="string">&quot;results/RMSVE_&#123;&#125;&quot;</span>.<span class="built_in">format</span>(save_name), rmsve = agent_rmsve,</span><br><span class="line">                                                   eval_freq = experiment_parameters[<span class="string">&quot;episode_eval_frequency&quot;</span>],</span><br><span class="line">                                                   num_episodes = experiment_parameters[<span class="string">&quot;num_episodes&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run Experiment</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Experiment parameters</span></span><br><span class="line">experiment_parameters = &#123;</span><br><span class="line">    <span class="string">&quot;num_runs&quot;</span> : <span class="number">20</span>,</span><br><span class="line">    <span class="string">&quot;num_episodes&quot;</span> : <span class="number">1000</span>,</span><br><span class="line">    <span class="string">&quot;episode_eval_frequency&quot;</span> : <span class="number">10</span> <span class="comment"># evaluate every 10 episode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Environment parameters</span></span><br><span class="line">environment_parameters = &#123;</span><br><span class="line">    <span class="string">&quot;num_states&quot;</span> : <span class="number">500</span>,</span><br><span class="line">    <span class="string">&quot;start_state&quot;</span> : <span class="number">250</span>,</span><br><span class="line">    <span class="string">&quot;left_terminal_state&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;right_terminal_state&quot;</span> : <span class="number">501</span>,</span><br><span class="line">    <span class="string">&quot;discount_factor&quot;</span> : <span class="number">1.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Agent parameters</span></span><br><span class="line">agent_parameters = &#123;</span><br><span class="line">    <span class="string">&quot;num_hidden_layer&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;num_hidden_units&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">&quot;step_size&quot;</span>: <span class="number">0.001</span>,</span><br><span class="line">    <span class="string">&quot;beta_m&quot;</span>: <span class="number">0.9</span>,</span><br><span class="line">    <span class="string">&quot;beta_v&quot;</span>: <span class="number">0.999</span>,</span><br><span class="line">    <span class="string">&quot;epsilon&quot;</span>: <span class="number">0.0001</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current_env = RandomWalkEnvironment</span><br><span class="line">current_agent = TDAgent</span><br><span class="line"></span><br><span class="line"><span class="comment"># run experiment</span></span><br><span class="line">run_experiment(current_env, current_agent, environment_parameters, agent_parameters, experiment_parameters)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot result</span></span><br><span class="line">plot_script.plot_result([<span class="string">&quot;td_agent&quot;</span>])</span><br><span class="line"></span><br><span class="line">shutil.make_archive(<span class="string">&#x27;results&#x27;</span>, <span class="string">&#x27;zip&#x27;</span>, <span class="string">&#x27;results&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Setting - Neural Network with 100 hidden units</code></pre>
<figure>
<img src="output_39_2.png" alt="png" /><figcaption aria-hidden="true">png</figcaption>
</figure>
<pre><code>&#39;/home/jovyan/work/release/TD-NN/results.zip&#39;</code></pre>
<p>You plotted the learning curve for 1000 episodes. As you can see the RMSVE is still decreasing. Here we provide the pre-computed result for 5000 episodes and 20 runs so that you can see the performance of semi-gradient TD with a neural network after being trained for a long time.</p>
<p><img src="nn_5000_episodes.png" /></p>
<p>Does semi-gradient TD with a neural network find a good approximation within 5000 episodes?</p>
<p>As you may remember from the previous assignment, semi-gradient TD with 10-state aggregation converged within 100 episodes. Why is TD with a neural network slower?</p>
<p>Would it be faster if we decrease the number of hidden units? Or what about if we increase the number of hidden units?</p>
<h2 id="compare-performance-of-semi-gradient-td-with-a-neural-network-and-semi-gradient-td-with-tile-coding">2-2: Compare Performance of Semi-gradient TD with a Neural Network and Semi-gradient TD with Tile-coding</h2>
<p>In this section, we compare the performance of semi-gradient TD with a Neural Network and semi-gradient TD with tile-coding. Tile-coding is a kind of coarse coding that uses multiple overlapping partitions of the state space to produce features. For tile-coding, we used 50 tilings each with 6 tiles. We set the step-size for semi-gradient TD with tile-coding to <span class="math inline">\(\frac{0.1}{tilings}\)</span>. See the figure below for the comparison between semi-gradient TD with tile-coding and semi-gradient TD with a neural network and Adam algorithm. This result is for 5000 episodes and 20 runs:</p>
<p><img src="nn_vs_tc.png" /></p>
<p>How are the results?</p>
<p>Semi-gradient TD with tile-coding is much faster than semi-gradient TD with a neural network. Why?</p>
<p>Which method has a lower RMSVE at the end of 5000 episodes?</p>
<h3 id="wrapping-up">Wrapping up!</h3>
<p>You have successfully implemented Course 3 Programming Assignment 2.</p>
<p>You have implemented <strong>semi-gradient TD with a Neural Network and Adam algorithm</strong> in 500-state Random Walk.</p>
<p>You also compared semi-gradient TD with a neural network and semi-gradient TD with tile-coding.</p>
<p>From the experiments and lectures, you should be more familiar with some of the strengths and weaknesses of using neural networks as the function approximator for an RL agent. On one hand, neural networks are powerful function approximators capable of representing a wide class of functions. They are also capable of producing features without exclusively relying on hand-crafted mechanisms. On the other hand, compared to a linear function approximator with tile-coding, neural networks can be less sample efficient. When implementing your own Reinforcement Learning agents, you may consider these strengths and weaknesses to choose the proper function approximator for your problems.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/TD-with-State-Aggregation/2020/10/13/" rel="prev" title="TD with State Aggregation ">
      <i class="fa fa-chevron-left"></i> TD with State Aggregation 
    </a></div>
      <div class="post-nav-item">
    <a href="/Function-Approximation-and-Control/2020/10/15/" rel="next" title="Function Approximation and Control">
      Function Approximation and Control <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#assignment-2---semi-gradient-td-with-a-neural-network"><span class="nav-number">1.</span> <span class="nav-text">Assignment 2 - Semi-gradient TD with a Neural Network</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#packages"><span class="nav-number">1.1.</span> <span class="nav-text">Packages</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section-1-create-semi-gradient-td-with-a-neural-network"><span class="nav-number">1.2.</span> <span class="nav-text">Section 1: Create semi-gradient TD with a Neural Network</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#implement-helper-methods"><span class="nav-number">1.3.</span> <span class="nav-text">1-1: Implement helper methods</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#implement-get_value"><span class="nav-number">1.3.1.</span> <span class="nav-text">Implement get_value()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#implement-get_gradient"><span class="nav-number">1.3.2.</span> <span class="nav-text">Implement get_gradient()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#implement-stochastic-gradient-descent-method-for-state-value-prediction"><span class="nav-number">1.3.3.</span> <span class="nav-text">Implement stochastic gradient descent method for state-value prediction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#adam-algorithm"><span class="nav-number">1.3.4.</span> <span class="nav-text">Adam Algorithm</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#implement-agent-methods"><span class="nav-number">1.4.</span> <span class="nav-text">1-2: Implement Agent Methods</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section-2---run-experiment"><span class="nav-number">1.5.</span> <span class="nav-text">Section 2 - Run Experiment</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#run-experiment-for-semi-gradient-td-with-a-neural-network"><span class="nav-number">1.6.</span> <span class="nav-text">2-1: Run Experiment for Semi-gradient TD with a Neural Network</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#compare-performance-of-semi-gradient-td-with-a-neural-network-and-semi-gradient-td-with-tile-coding"><span class="nav-number">1.7.</span> <span class="nav-text">2-2: Compare Performance of Semi-gradient TD with a Neural Network and Semi-gradient TD with Tile-coding</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wrapping-up"><span class="nav-number">1.7.1.</span> <span class="nav-text">Wrapping up!</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ruochi Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">268</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangruochi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangruochi" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zrc720@gmail.com" title="E-Mail → mailto:zrc720@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.healthinformaticslab.org/" title="http:&#x2F;&#x2F;www.healthinformaticslab.org" rel="noopener" target="_blank">HILab</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.shihaizhou.com/" title="http:&#x2F;&#x2F;www.shihaizhou.com" rel="noopener" target="_blank">Rose</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/cherish_CX/" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;cherish_CX&#x2F;" rel="noopener" target="_blank">Chunxia</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ruochi Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qW3MLcAgcX96sB6qbegeL7rP-gzGzoHsz',
      appKey     : 'GL6JvT9DgGxqYrY5Vj6bXVuv',
      placeholder: "Thank you for your reply",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'en' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
