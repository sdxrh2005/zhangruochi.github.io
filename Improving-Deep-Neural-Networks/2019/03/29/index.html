<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PingFang SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangruochi.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="This is course note of the deep learning specialization at lectured by Andrew Ng.">
<meta property="og:type" content="article">
<meta property="og:title" content="Improving Deep Neural Networks">
<meta property="og:url" content="https://zhangruochi.com/Improving-Deep-Neural-Networks/2019/03/29/index.html">
<meta property="og:site_name" content="RUOCHI.AI">
<meta property="og:description" content="This is course note of the deep learning specialization at lectured by Andrew Ng.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhangruochi.com/Improving-Deep-Neural-Networks/2019/03/29/Images/01-_Bias_-_Variance.png">
<meta property="og:image" content="https://zhangruochi.com/Improving-Deep-Neural-Networks/2019/03/29/Images/02-_Early_stopping.png">
<meta property="og:image" content="https://zhangruochi.com/Improving-Deep-Neural-Networks/2019/03/29/Images/03-_Numerical_approximation_of_gradients.png">
<meta property="og:image" content="https://zhangruochi.com/Improving-Deep-Neural-Networks/2019/03/29/Images/04-_batch_vs_mini_batch_cost.png">
<meta property="og:image" content="https://zhangruochi.com/Improving-Deep-Neural-Networks/2019/03/29/Images/Nasdaq1_small.png">
<meta property="og:image" content="https://zhangruochi.com/Improving-Deep-Neural-Networks/2019/03/29/Images/05-_exponentially_weighted_averages_intuitions.png">
<meta property="og:image" content="https://zhangruochi.com/Improving-Deep-Neural-Networks/2019/03/29/Images/06-_RMSprop.png">
<meta property="og:image" content="https://zhangruochi.com/Improving-Deep-Neural-Networks/2019/03/29/Images/bn.png">
<meta property="og:image" content="https://zhangruochi.com/Improving-Deep-Neural-Networks/2019/03/29/Images/07-_softmax.png">
<meta property="article:published_time" content="2019-03-29T09:58:57.000Z">
<meta property="article:modified_time" content="2019-07-05T09:54:32.000Z">
<meta property="article:author" content="Ruochi Zhang">
<meta property="article:tag" content="Course Note">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangruochi.com/Improving-Deep-Neural-Networks/2019/03/29/Images/01-_Bias_-_Variance.png">

<link rel="canonical" href="https://zhangruochi.com/Improving-Deep-Neural-Networks/2019/03/29/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Improving Deep Neural Networks | RUOCHI.AI</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RUOCHI.AI</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhangruochi.com/Improving-Deep-Neural-Networks/2019/03/29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ruochi Zhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RUOCHI.AI">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Improving Deep Neural Networks
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-29 17:58:57" itemprop="dateCreated datePublished" datetime="2019-03-29T17:58:57+08:00">2019-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-07-05 17:54:32" itemprop="dateModified" datetime="2019-07-05T17:54:32+08:00">2019-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Artificial-Intelligence/" itemprop="url" rel="index"><span itemprop="name">Artificial Intelligence</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Artificial-Intelligence/Deep-Learning/" itemprop="url" rel="index"><span itemprop="name">Deep Learning</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/Improving-Deep-Neural-Networks/2019/03/29/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Improving-Deep-Neural-Networks/2019/03/29/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">This is course note of the deep learning specialization at lectured by Andrew Ng.</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>Reference from lecture slides of Andrew Ng and github repo from <a target="_blank" rel="noopener" href="https://github.com/mbadry1/DeepLearning.ai-Summary">DeepLearning.ai-Summary</a></strong></p>
<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#improving-deep-neural-networks-hyperparameter-tuning-regularization-and-optimization">Improving Deep Neural Networks: Hyperparameter tuning, Regularization and Optimization</a>
<ul>
<li><a href="#table-of-contents">Table of contents</a></li>
<li><a href="#course-summary">Course summary</a></li>
<li><a href="#practical-aspects-of-deep-learning">Practical aspects of Deep Learning</a>
<ul>
<li><a href="#train--dev--test-sets">Train / Dev / Test sets</a></li>
<li><a href="#bias--variance">Bias / Variance</a></li>
<li><a href="#basic-recipe-for-machine-learning">Basic Recipe for Machine Learning</a></li>
<li><a href="#regularization">Regularization</a></li>
<li><a href="#dropout-regularization">Dropout Regularization</a></li>
<li><a href="#understanding-dropout">Understanding Dropout</a></li>
<li><a href="#other-regularization-methods">Other regularization methods</a></li>
<li><a href="#normalizing-inputs">Normalizing inputs</a></li>
<li><a href="#vanishing--exploding-gradients">Vanishing / Exploding gradients</a></li>
<li><a href="#weight-initialization-for-deep-networks">Weight Initialization for Deep Networks</a></li>
<li><a href="#numerical-approximation-of-gradients">Numerical approximation of gradients</a></li>
<li><a href="#gradient-checking-implementation-notes">Gradient checking implementation notes</a></li>
</ul></li>
<li><a href="#optimization-algorithms">Optimization algorithms</a>
<ul>
<li><a href="#mini-batch-gradient-descent">Mini-batch gradient descent</a></li>
<li><a href="#understanding-mini-batch-gradient-descent">Understanding mini-batch gradient descent</a></li>
<li><a href="#exponentially-weighted-averages">Exponentially weighted averages</a></li>
<li><a href="#understanding-exponentially-weighted-averages">Understanding exponentially weighted averages</a></li>
<li><a href="#bias-correction-in-exponentially-weighted-averages">Bias correction in exponentially weighted averages</a></li>
<li><a href="#gradient-descent-with-momentum">Gradient descent with momentum</a></li>
<li><a href="#rmsprop">RMSprop</a></li>
<li><a href="#adam-optimization-algorithm">Adam optimization algorithm</a></li>
<li><a href="#learning-rate-decay">Learning rate decay</a></li>
<li><a href="#the-problem-of-local-optima">The problem of local optima</a></li>
</ul></li>
<li><a href="#hyperparameter-tuning-batch-normalization-and-programming-frameworks">Hyperparameter tuning, Batch Normalization and Programming Frameworks</a>
<ul>
<li><a href="#tuning-process">Tuning process</a></li>
<li><a href="#using-an-appropriate-scale-to-pick-hyperparameters">Using an appropriate scale to pick hyperparameters</a></li>
<li><a href="#hyperparameters-tuning-in-practice-pandas-vs-caviar">Hyperparameters tuning in practice: Pandas vs. Caviar</a></li>
<li><a href="#normalizing-activations-in-a-network">Normalizing activations in a network</a></li>
<li><a href="#fitting-batch-normalization-into-a-neural-network">Fitting Batch Normalization into a neural network</a></li>
<li><a href="#why-does-batch-normalization-work">Why does Batch normalization work</a></li>
<li><a href="#batch-normalization-at-test-time">Batch normalization at test time</a></li>
<li><a href="#softmax-regression">Softmax Regression</a></li>
<li><a href="#training-a-softmax-classifier">Training a Softmax classifier</a></li>
<li><a href="#deep-learning-frameworks">Deep learning frameworks</a></li>
<li><a href="#tensorflow">TensorFlow</a></li>
</ul></li>
<li><a href="#extra-notes">Extra Notes</a></li>
</ul></li>
</ul>
<h2 id="course-summary">Course summary</h2>
<p>Here are the course summary as its given on the course <a target="_blank" rel="noopener" href="https://www.coursera.org/learn/deep-neural-network">link</a>:</p>
<blockquote>
<p>This course will teach you the "magic" of getting deep learning to work well. Rather than the deep learning process being a black box, you will understand what drives performance, and be able to more systematically get good results. You will also learn TensorFlow.</p>
<p>After 3 weeks, you will: - Understand industry best-practices for building deep learning applications. - Be able to effectively use the common neural network "tricks", including initialization, L2 and dropout regularization, Batch normalization, gradient checking, - Be able to implement and apply a variety of optimization algorithms, such as mini-batch gradient descent, Momentum, RMSprop and Adam, and check for their convergence. - Understand new best-practices for the deep learning era of how to set up train/dev/test sets and analyze bias/variance - Be able to implement a neural network in TensorFlow.</p>
<p>This is the second course of the Deep Learning Specialization.</p>
</blockquote>
<h2 id="practical-aspects-of-deep-learning">Practical aspects of Deep Learning</h2>
<h3 id="train-dev-test-sets">Train / Dev / Test sets</h3>
<ul>
<li>Its impossible to get all your hyperparameters right on a new application from the first time.</li>
<li>So the idea is you go through the loop: <code>Idea ==&gt; Code ==&gt; Experiment</code>.</li>
<li>You have to go through the loop many times to figure out your hyperparameters.</li>
<li>Your data will be split into three parts:
<ul>
<li>Training set. (Has to be the largest set)</li>
<li>Dev set or Validation set.</li>
<li>Testing set.</li>
</ul></li>
<li>You will try to build a model upon training set then try to optimize hyperparameters on Dev set as much as possible. Then after your model is ready you try and evaluate the testing set.</li>
<li>so the trend on the ratio of splitting the models:
<ul>
<li>If size of the dataset is 100 to 1000000 ==&gt; 60/20/20</li>
<li>If size of the dataset is 1000000 to INF ==&gt; 98/1/1 or 99.5/0.25/0.25</li>
</ul></li>
<li>The trend now gives the training data the biggest sets.</li>
<li>Make sure the Training/Dev/test set is coming from the same distribution.
<ul>
<li>For example if cat training pictures is from the web and the Dev/test pictures are from users cell phone they will mismatch. It is better to make them one distribution.</li>
</ul></li>
<li>The Dev set rule is to try them on some of the good models you've created.</li>
<li>Its OK to only have a Dev set without a testing set.</li>
<li>Almost all people call the Dev set as the test set. But a better terminology is to call it a Dev set as its used in the development.</li>
</ul>
<h3 id="bias-variance">Bias / Variance</h3>
<ul>
<li>Bias / Variance techniques are Easy to learn, but difficult to master.</li>
<li>So here the explanation of Bias / Variance:
<ul>
<li>If your model is underfitting (logistic regression of non linear data) it has a "high bias"</li>
<li>If your model is overfitting then it has a "high variance"</li>
<li>Your model will be alright if you balance the Bias / Variance</li>
<li>For more:
<ul>
<li><img src="Images/01-_Bias_-_Variance.png" /></li>
</ul></li>
</ul></li>
<li>Another idea to get the bias / variance if you don't have a 2D plotting mechanism:
<ul>
<li>High variance (overfitting) for example:
<ul>
<li>Training error: 1%</li>
<li>Dev error: 11%</li>
</ul></li>
<li>high Bias (underfitting) for example:
<ul>
<li>Training error: 15%</li>
<li>Dev error: 14%</li>
</ul></li>
<li>high Bias (underfitting) &amp;&amp; High variance (overfitting) for example:
<ul>
<li>Training error: 15%</li>
<li>Test error: 30%</li>
</ul></li>
<li>Best:
<ul>
<li>Training error: 0.5%</li>
<li>Test error: 1%</li>
</ul></li>
<li>These Assumptions came from that human has 0% error. If the problem isn't like that you'll need to use human error as baseline.</li>
</ul></li>
</ul>
<h3 id="basic-recipe-for-machine-learning">Basic Recipe for Machine Learning</h3>
<ul>
<li>If your algorithm has a high bias:
<ul>
<li>Try to make your NN bigger (Size of Hidden units, Number of layers)</li>
<li>Try a different model that are suitable for your data.</li>
<li>Try to run it longer.</li>
<li>Different optimization algorithm.</li>
</ul></li>
<li>If your algorithm has a high variance:
<ul>
<li>More data.</li>
<li>Try regularization.</li>
<li>Try a different model that are suitable for your data.</li>
</ul></li>
<li>You should try the previous two points until you have a low bias / low variance.</li>
<li>In the older days before deep learning there was a "Bias / variance trade off". But because now you have more options on solving the bias and variance problem its really helpful to use deep learning.</li>
<li>Training a bigger neural network never hurt.</li>
</ul>
<h3 id="regularization">Regularization</h3>
<ul>
<li>Adding Regularization to NN will help it reduce variance (Overfitting)</li>
<li>L1 matrix Norm:
<ul>
<li><code>||W|| = Sum(|W[i,j]|)      # Sum of all Ws with abs</code></li>
</ul></li>
<li>L2 matrix Norm sometimes its called Frobenius norm:
<ul>
<li><code>||W||^2 = Sum(|W[i,j]|^2)  #Sum of all Ws squared</code></li>
<li>Also can be calculated using<code>||W||^2 = W.T * W</code></li>
</ul></li>
<li>Regularization For logistic regression:
<ul>
<li>The normal cost function that we want to minimize is: <code>J(w,b) = (1/m) * Sum(L(y(i),y'(i)))</code></li>
<li>The L2 Regularization version: <code>J(w,b) = (1/m) * Sum(L(y(i),y'(i))) + (Lmda/2m) * ||W||^2</code></li>
<li>The L1 Regularization version: <code>J(w,b) = (1/m) * Sum(L(y(i),y'(i))) + (Lmda/2m) * (||W||)</code></li>
<li>The L1 Regularization version makes a lot of w values become zeros, which makes the model size is small.</li>
<li>L2 Regularization is being used much often.</li>
<li><code>Lmda</code> here is the Regularization parameter (Hyperparameter)</li>
</ul></li>
<li>Regularization For NN:
<ul>
<li><p>The normal cost function that we want to minimize is: <code>J(W1,b1...,WL,bL) = (1/m) * Sum(L(y(i),y'(i)))</code></p></li>
<li><p>The L2 Regularization version: <code>J(w,b) = (1/m) * Sum(L(y(i),y'(i))) + (Lmda/2m) * Sum((||W[l]||) ^2)</code></p></li>
<li><p>We stack the matrix as one vector <code>(mn,1)</code> and then we apply <code>sqrt(w1^2+w2^2.....)</code></p></li>
<li><p>To do back propagation (old way):</p>
<p><code>w[l] = w[l] - learningRate * dw[l]</code></p></li>
<li><p>The new way:</p>
<p><code>dw[l] = (Back prob) + (Lmda/m)*w[l]</code></p></li>
<li><p>So:</p>
<ul>
<li><code>w[l] = w[l] - (Lmda/m)*w[l] - learningRate * dw[l]</code></li>
<li><code>w[l] = (1 - (learninRate*Lmda)/m) w[l] - learninRate*dw[l]</code></li>
</ul></li>
<li><p>In practice this penalizes large weights and effectively limits the freedom in your model.</p></li>
<li><p>The new term <code>(1 - (learninRate*Lmda)/m) w[l]</code> causes the weight to decay in proportion to its size.</p></li>
</ul></li>
<li>Why regularization reduces overfitting? Here are some intuitions:
<ol type="1">
<li>Number 1
<ul>
<li>If <code>Lmda</code> is too large, as the equations we discussed before a lot of w's will be zeros which will make the NN act like logistic regression.</li>
<li>If <code>Lmda</code> is good enough it will just reduce some weights that makes the neural network overfit.</li>
</ul></li>
<li>Number 2 (in Tanh activation function)
<ul>
<li>If <code>Lmda</code> is too large, w's will be small which makes the Tanh activation function to be from non linear to linear which makes the NN a linear classifier.</li>
<li>If <code>Lmda</code> good enough it will just make some Tanh activation a linear classifier which will prevent overfitting.</li>
</ul></li>
</ol></li>
</ul>
<h3 id="dropout-regularization">Dropout Regularization</h3>
<ul>
<li><p>In the most cases Andrew Ng tells that he uses the L1/L2 regularization.</p></li>
<li><p>The dropout Regularization eliminates some neurons/weights on each iteration based on a probability.</p></li>
<li><p>A technique called "Inverse dropout" is one of the techniques that are used to implement Inverse dropout.</p></li>
<li><p>Code for Inverse dropout:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">keep_prob = 0.8</span><br><span class="line">l = 3          # This code will work only on layer 3</span><br><span class="line"># the generated number that are less than 0.8 will be dropped. 80% stay, 20% dropped</span><br><span class="line">d3 = np.random.randn(a[l].shape[0], a[l].shape[1]) &lt; keep_prob</span><br><span class="line"></span><br><span class="line">a3 = np.multiply(a3,d3)   #Keeps only the values in d3</span><br><span class="line"></span><br><span class="line"># Maximize a3 again to gain the loss (The expected value of a3 is the same) - To solve the</span><br><span class="line"># scaling problem</span><br><span class="line">a3 = a3 / keep_prob       </span><br></pre></td></tr></table></figure></li>
<li><p>At test time we don't run the "Inverse dropout"</p></li>
</ul>
<h3 id="understanding-dropout">Understanding Dropout</h3>
<ul>
<li>Can't rely on one feature so have to spread out weights</li>
<li>Dropout can have different dropouts per layer.</li>
<li>The input layer drop out is has to be near 1 because we need to learn a lot from the input.</li>
<li>A lot of researchers are using dropout with CNN.</li>
<li>Downside of dropout is that the loss function is not well defined and it will be hard to debug.
<ul>
<li>To solve that you'll need to set all the dropouts by 1 and then check your cost graph if its going well set the dropouts again.</li>
</ul></li>
</ul>
<h3 id="other-regularization-methods">Other regularization methods</h3>
<ul>
<li><strong>Data augmentation</strong>:
<ul>
<li>For example in a computer vision data:
<ul>
<li>You can flip all your pictures horizontally this will give you m more data instances.</li>
<li>You could also take a random position and rotation in an image to get more data.</li>
</ul></li>
<li>For example in OCR, you'll need to distort the digits.</li>
<li>This technique's new data isn't as good as the real independent data, but still can be used as a Regularization technique.</li>
</ul></li>
<li><strong>Early stopping</strong>:
<ul>
<li>In this technique we plot the training data and the Dev data cost together. At some iteration the Dev data cost will stop decreasing.</li>
<li>We will pick the point at which the training data graph and Dev data graph are best (lowest training cost with lowest dev cost).</li>
<li>We will take these parameters as the best parameters.
<ul>
<li><img src="Images/02-_Early_stopping.png" /></li>
</ul></li>
<li>This technique is not recommended because it makes us think about something else more than optimize W's and b's.</li>
<li>But its advantage is that you don't need to modify a Hyperparameter like in Regularization.</li>
</ul></li>
<li><strong>Model Ensembles</strong>:
<ul>
<li>Algorithm:
<ul>
<li>Train multiple independent models.</li>
<li>At test time average their results.</li>
</ul></li>
<li>It can get you extra 2% performance.</li>
<li>It reduces the generalization error.</li>
<li>You can use some snapshots of your NN at the training ensembles them and take the results.</li>
</ul></li>
</ul>
<h3 id="normalizing-inputs">Normalizing inputs</h3>
<ul>
<li>If you normalize your inputs this will speed up the training process a lot.</li>
<li>Normalization are going on these steps:
<ol type="1">
<li>Get mean. <code>Mean = (1/m) * sum(x(i))</code></li>
<li>Subtract the mean from each input. <code>X = X - Mean</code>
<ul>
<li>This makes your inputs centered around 0.</li>
</ul></li>
<li>Get the variance. <code>variance = (1/m) * sum(x(i)^2)</code></li>
<li>Normalize the variance. <code>X/= variance</code></li>
</ol></li>
<li>These steps should be applied to training, Dev, and testing sets.</li>
<li>Why normalize?
<ul>
<li>If we don't normalize the inputs our loss function will be deep and its shape is inconsistent then optimizing it will take a long time.</li>
<li>But if we normalize it the opposite will occur. the shape of the function will be consistent and the optimizing will be easier.</li>
</ul></li>
</ul>
<h3 id="vanishing-exploding-gradients">Vanishing / Exploding gradients</h3>
<ul>
<li>The Vanishing / Exploding gradients occurs when your derivatives become very small or very big.</li>
<li>To understand the problem, suppose that we have a deep neural network with number of layers L, and all the activation functions are <strong>linear</strong> and each <code>b = 0</code>
<ul>
<li><p>Then:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y&#x27; = W[L]W[L-1].....W[2]W[1]X</span><br></pre></td></tr></table></figure></li>
<li><p>Then, if we have 2 layers, in each layer, we have two assumptions:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Y&#x27; = (W[L][1.5  0]^(L-1)) X = 1.5^L     # which will be so large</span><br><span class="line">          [0  1.5]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Y&#x27; = (W[L][0.5  0]^(L-1)) X = 0.5^L     # which will be so small</span><br><span class="line">          [0  0.5]</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>The last example explains that the derivatives will be decreased/Increased exponentially.</li>
<li>So If W &gt; I (Identity matrix) The weights will explode.</li>
<li>And If W &lt; I (Identity matrix) The weights will vanish.</li>
<li>Recently Microsoft trained 152 layers (ResNet)! which is a really big number.</li>
</ul>
<h3 id="weight-initialization-for-deep-networks">Weight Initialization for Deep Networks</h3>
<ul>
<li><p>A partial solution to the Vanishing / Exploding gradients in NN is better or more careful choice of the random initialization of weights.</p></li>
<li><p>In a single neuron (Perceptron model): <code>Z = w1X1 + w2X2 + ...+wnXn</code></p>
<ul>
<li>So if <code>Nx</code> is large we want <code>W</code>'s to be smaller to not explode the cost.</li>
</ul></li>
<li><p>So it turns out that we need the variance which equals <code>1/Nx</code> to be the range of <code>W</code>'s</p></li>
<li><p>So lets say when we initialize <code>W</code>'s we initialize like this (For Tanh its better to use this):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.rand(shape)*np.sqrt(1/n[l-1])               #n[l-1] In the multiple layers.</span><br></pre></td></tr></table></figure></li>
<li><p>Setting this to <code>2/n[l-1]</code> especially for RELU is better:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.rand(shape)*np.sqrt(2/n[l-1])               #n[l-1] In the multiple layers.</span><br></pre></td></tr></table></figure></li>
<li><p>This is the best way to solve Vanishing / Exploding gradients (RELU + Weight Initialization with variance)</p></li>
<li><p>The initialization in this video is called "He Initialization / Xavier Initialization" and has been published in 2015 paper.</p></li>
</ul>
<h3 id="numerical-approximation-of-gradients">Numerical approximation of gradients</h3>
<ul>
<li>There is an implementation called gradient check which tells if your implementation of back prob. is right.</li>
<li>There's a numerical way to calculate the derivative
<ul>
<li><img src="Images/03-_Numerical_approximation_of_gradients.png" /></li>
</ul></li>
<li>This checking is so helpful at finding the errors in your back prob. algorithm but its slower than gradient descent.</li>
<li>Implementation of this is so simple.</li>
<li>Gradient checking:
<ul>
<li><p>First take <code>W[1],b[1]...W[L]b[L]</code> and reshape into one big vector (<code>Ceta</code>)</p></li>
<li><p>The cost function will be <code>L(Ceta)</code></p></li>
<li><p>Then take <code>dW[1],db[1]......dW[L]db[L]</code> into one big vector (<code>d_ceta</code>)</p></li>
<li><p><strong>Algorithm</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eps = 10^-7   #Small number</span><br><span class="line">for i in len(Ceta):</span><br><span class="line">    d_ceta_calc[i] = (J(ceta1,..,ceta[i] + eps) -  J(ceta1,..,ceta[i] - eps)) / 2*eps</span><br></pre></td></tr></table></figure></li>
<li><p>Finally we check this formula <code>(||d_ceta_calc - d_ceta||) / (||d_ceta_calc||+||d_ceta||)</code></p>
<ul>
<li>The <code>||</code> is the Euclidean distance.</li>
</ul></li>
</ul></li>
</ul>
<h3 id="gradient-checking-implementation-notes">Gradient checking implementation notes</h3>
<ul>
<li>Don't use the gradient-checking algorithm for all the calculation because its a much slow algorithm</li>
<li>The gradient-checking is for debugging.</li>
<li>If algorithm fails grad check, look at components to try to identify the bug.</li>
<li>Don't forget to add <code>(lamda/2m)sum(W[l])</code> to <code>J</code> if you are using L1 or L2 regularization.</li>
<li>Gradient checking doesn't work with dropout.
<ul>
<li>because J is not consistent.</li>
</ul></li>
<li>Run gradient checking at random initialization and train the network for a while maybe there's a bug that are not on the first iteration.</li>
</ul>
<h2 id="optimization-algorithms">Optimization algorithms</h2>
<h3 id="mini-batch-gradient-descent">Mini-batch gradient descent</h3>
<ul>
<li><p>Training NN with a large data is slow. So to find an optimization algorithm that runs faster is a good idea.</p></li>
<li><p>Suppose we have <code>m = 50 million.</code> To train this data it will take a huge processing time for one step.</p>
<ul>
<li>because 50 million won't fit in the memory at once we need other processing to make such a thing.</li>
</ul></li>
<li><p>It turns out you can make a faster algorithm to make gradient decent process some of your items even before you finish the 50 million items.</p></li>
<li><p>Suppose we have split m to <strong>mini batches</strong>.</p>
<ul>
<li><code>X&#123;1&#125; = 0    ==&gt;  1000</code></li>
<li><code>X&#123;2&#125; = 1001 ==&gt;  2000</code></li>
<li><code>....</code></li>
<li><code>X&#123;bs&#125; = ...</code></li>
</ul></li>
<li><p>We similarly split <code>X</code> &amp; <code>Y</code>.</p></li>
<li><p>So the definition of mini batches ==&gt; <code>t: X&#123;t&#125;, Y&#123;t&#125;</code></p></li>
<li><p>In <strong>Batch gradient descent</strong> We run the gradient decent on the whole dataset.</p></li>
<li><p>While in <strong>Mini-Batch gradient descent</strong> We run the gradient decent on the mini datasets.</p></li>
<li><p>Mini-Batch algorithm pseudo code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for t = 1:No_of_batches                                     #This is called on epoch</span><br><span class="line">  AL, caches = forward_prop(X&#123;t&#125;, Y&#123;t&#125;)</span><br><span class="line">  Cost = compute_cost(AL, Y&#123;t&#125;)</span><br><span class="line">  grads = backward_prop(AL, caches)</span><br><span class="line">  UpdateParameters(grads)</span><br></pre></td></tr></table></figure></li>
<li><p>The code inside an epoch should be vectorized.</p></li>
<li><p>This works much faster in the large datasets.</p></li>
</ul>
<h3 id="understanding-mini-batch-gradient-descent">Understanding mini-batch gradient descent</h3>
<ul>
<li>In mini batch algorithm, the cost won't go down with each step as batch algorithm do. It could contain some ups and downs but at whole it has to go down.
<ul>
<li><img src="Images/04-_batch_vs_mini_batch_cost.png" /></li>
</ul></li>
<li>Choosing mini-batch size
<ul>
<li>If (<code>mini batch size = m</code>) ==&gt; Batch gradient descent
<ul>
<li>If (<code>mini batch size = 1</code>) ==&gt; Stochastic gradient descent</li>
<li>Might be faster than standard in big data <code>&gt; 10^7</code></li>
<li>If (<code>mini batch size = between 1 and m</code>) ==&gt; Mini Batch gradient descent</li>
</ul></li>
</ul></li>
<li>In Stochastic gradient descent is so noisy regarding cost minimization and won't reach the minimum cost. Also you lose vectorization advantage.</li>
<li>In mini batch gradient descent is so noisy regarding cost minimization and won't reach the minimum cost. But you have the vectorization advantage and you can look at the costs when the code is running to see if its right. To help with the noisy cost minimization you should reduce the learning rate.</li>
<li>Guidelines for using mini batch:
<ul>
<li>It has to be a power of 2 to take advantage of vectorization: <code>64, 128, 256, 512, 1024....</code></li>
<li>Make sure mini-batch fits in CPU/GPU</li>
</ul></li>
<li>Mini batch size is a Hyperparameter.</li>
</ul>
<h3 id="exponentially-weighted-averages">Exponentially weighted averages</h3>
<ul>
<li><p>There are optimization algorithms that are better than <strong>gradient descent</strong>. but you should first learn about Exponentially weighted averages.</p></li>
<li><p>If we have data like the temperature of day through the year it could be like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t(1) = 40</span><br><span class="line">t(2) = 49</span><br><span class="line">t(3) = 45</span><br><span class="line">..</span><br><span class="line">t(180) = 60</span><br><span class="line">..</span><br></pre></td></tr></table></figure></li>
<li><p>This data is small in winter and big in summer. If we plot this data we will find it some noisy.</p></li>
<li><p>Now lets compute the Exponentially weighted averages:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">V0 = 0</span><br><span class="line">V1 = 0.9 * V0 + 0.1 * t(1) = 4        # 0.9 and 0.1 are hyperparameters</span><br><span class="line">V2 = 0.9 * V1 + 0.1 * t(2) = 8.5</span><br><span class="line">V3 = 0.9 * V2 + 0.1 * t(3) = 12.15</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>If we plot this it will represent averages.</p></li>
<li><p>Another imagery example:</p>
<ul>
<li><img src="Images/Nasdaq1_small.png" /></li>
<li>Taken from: <a href="investopedia.com">investopedia.com</a></li>
</ul></li>
<li><p>General equation</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V(t) = beta v(t-1) + (1-beta) ceta(t)</span><br></pre></td></tr></table></figure>
<ul>
<li>If <code>beta = 0.9</code> then we are averaging through this equation: <code>(1/ (1-beta))</code> Then
<ul>
<li>beta = 0.9 will average last 10 entries.</li>
<li>beta = 0.98 will average last 50 entries.</li>
<li>beta = 0.5 will average last 2 entries.</li>
</ul></li>
</ul></li>
<li><p>Best beta average for our case is between 0.9 and 0.98</p></li>
</ul>
<h3 id="understanding-exponentially-weighted-averages">Understanding exponentially weighted averages</h3>
<ul>
<li><p>Intuitions:</p>
<ul>
<li><img src="Images/05-_exponentially_weighted_averages_intuitions.png" /></li>
</ul></li>
<li><p>We can implement this algorithm with more accurate results if we make a moving window. But the code is more efficient and faster using the exponentially weighted averages algorithm.</p></li>
<li><p>Algorithm is so simple:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">V = 0</span><br><span class="line">Repeat</span><br><span class="line">&#123;</span><br><span class="line">  Get ceta(t)</span><br><span class="line">  V = beta * V + (1-beta) * ceta(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="bias-correction-in-exponentially-weighted-averages">Bias correction in exponentially weighted averages</h3>
<ul>
<li><p>The bias correction helps making the exponentially weighted averages more accurate.</p></li>
<li><p>Because <code>V(0) = 0</code>, the bias of the weighted averages is shifted and the accuracy suffers.</p></li>
<li><p>To solve the bias issue we have to use this equation:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V(t) = (beta v(t-1) + (1-beta) ceta(t)) / (1 - beta^t)</span><br></pre></td></tr></table></figure></li>
<li><p>As you see the as t became larger the <code>(1 - beta^t)</code> became <code>1</code></p></li>
</ul>
<h3 id="gradient-descent-with-momentum">Gradient descent with momentum</h3>
<ul>
<li><p>The momentum algorithm works faster than standard Gradient descent.</p></li>
<li><p>The simple idea is to calculate the exponentially weighted averages for your gradients and then updates your weights with the new values.</p></li>
<li><p>Pseudo code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VdW = 0, Vdb = 0</span><br><span class="line">on iteration t:</span><br><span class="line">  # The mini batch can be the whole batch its ok</span><br><span class="line">  compute dw, db on current mini batch                </span><br><span class="line">          </span><br><span class="line">  VdW = (beta * VdW) + (1 - beta)dW</span><br><span class="line">  Vdb = (beta * Vdb) + (1 - beta)db</span><br><span class="line">  W = W - learning_rate * VdW</span><br><span class="line">  b = B - learning_rate * Vdb</span><br></pre></td></tr></table></figure></li>
<li><p>This will help the cost function to go to the minimum point in a more fast and consistent way.</p></li>
<li><p><code>beta = 0.9</code> is working very well for lots of people.</p></li>
<li><p>In practice people don't bother with <strong>Bias correction</strong> (They leave the first iterations to work as they want)</p></li>
</ul>
<h3 id="rmsprop">RMSprop</h3>
<ul>
<li><p>Stands for <strong>Root mean square prop</strong>.</p></li>
<li><p>This algorithm speeds up the Gradient descent.</p></li>
<li><p>Pseudo code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SdW = 0, Sdb = 0</span><br><span class="line">on iteration t:</span><br><span class="line">  # The mini batch can be the whole batch its ok</span><br><span class="line">  compute dw, db on current mini batch</span><br><span class="line">  </span><br><span class="line">  SdW = (beta * SdW) + (1 - beta)dW^2</span><br><span class="line">  Sdb = (beta * Sdb) + (1 - beta)db^2</span><br><span class="line">  W = W - learning_rate * dW/sqrt(SdW)</span><br><span class="line">  b = B - learning_rate * db/sqrt(Sdb)</span><br></pre></td></tr></table></figure></li>
<li><p>This algorithm will make the cost function move on the vertical direction slow and the horizontal direction fast, in the following example.</p>
<ul>
<li><img src="Images/06-_RMSprop.png" /></li>
</ul></li>
<li><p>Ensure that <code>SdW</code> is not zero by adding a small value to it (epsilon). <code>W = W - learning_rate * dW/(sqrt(SdW) + epsilon)</code></p></li>
<li><p>With this algorithm you can increase your learning rate.</p></li>
<li><p>Developed by Jeoffery Hinton on <a href="Coursea.com">Coursea.com</a>.</p></li>
</ul>
<h3 id="adam-optimization-algorithm">Adam optimization algorithm</h3>
<ul>
<li><p>Stands for <strong>Adaptive Momentum Estimation</strong>.</p></li>
<li><p>Adam optimization and RMSprop are among the optimization algorithms that worked very well with a lot of NN architectures.</p></li>
<li><p>Adam optimization simply puts RMSprop and momentum and puts the together!</p></li>
<li><p>Pseudo code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">VdW = 0, VdW = 0</span><br><span class="line">SdW = 0, Sdb = 0</span><br><span class="line">on iteration t:</span><br><span class="line">  # The mini batch can be the whole batch its ok</span><br><span class="line">  compute dw, db on current mini batch                </span><br><span class="line">          </span><br><span class="line">  VdW = (beta1 * dW) + (1 - beta1)dW                    #Momentum</span><br><span class="line">  Vdb = (beta1 * db) + (1 - beta1)db                  #Momentum</span><br><span class="line">          </span><br><span class="line">  SdW = (beta2 * dW) + (1 - beta2)dW^2                    #RMSprop</span><br><span class="line">  Sdb = (beta2 * db) + (1 - beta2)db^2                    #RMSprop</span><br><span class="line">          </span><br><span class="line">  VdW = VdW/ (1 - beta^t)         #Fixing bias</span><br><span class="line">  Vdb = Vdb/ (1 - beta^t)         #Fixing bias</span><br><span class="line">          </span><br><span class="line">  SdW = SdW/ (1 - beta^t)         #Fixing bias</span><br><span class="line">  Sdb = Sdb/ (1 - beta^t)         #Fixing bias</span><br><span class="line">                  </span><br><span class="line">  W = W - learning_rate * VdW/(sqrt(SdW) + epsilon)</span><br><span class="line">  b = B - learning_rate * Vdb/(sqrt(Sdb) + epsilon)</span><br></pre></td></tr></table></figure></li>
<li><p>Hyperparameters:</p>
<ul>
<li>Learning rate: needed to be tuned.</li>
<li><code>Beta1</code>. Parameter of the momentum. <code>0.9</code> is recommended by default.</li>
<li><code>Beta2</code>. Parameter of the RMSprop. <code>0.999</code> is recommended by default.</li>
<li><code>epsilon</code>. <code>10^-8</code> is recommended by default.</li>
</ul></li>
</ul>
<h3 id="learning-rate-decay">Learning rate decay</h3>
<ul>
<li>Slowly reduce learning rate.</li>
<li>In mini batch algorithm, we said that the minimization of the cost won't reach optimum point. But by making the learning rate decays with iterations it will reach it as the steps beside the optimum is small.</li>
<li>One technique equations is<code>learning_rate = (1 / (1 + decay_rate * epoch_num)) * learning_rate_0</code>
<ul>
<li><code>epoch_num</code> is over all data (not a single mini batch).</li>
</ul></li>
<li>Other learning rate decay methods (Continuous):
<ul>
<li><code>learning_rate = (0.95 ^ epoch_num) * learning_rate_0</code></li>
<li><code>learning_rate = (k / sqrt(epoch_num)) * learning_rate_0</code></li>
</ul></li>
<li>Some people is making changing the learning rate manually.</li>
<li>For Andrew Ng, learning rate decay has less priority</li>
</ul>
<h3 id="the-problem-of-local-optima">The problem of local optima</h3>
<ul>
<li>The normal local optima is not likely to appear in a deep neural network.</li>
<li>You are unlikely to get stuck in a bad local optima in high dimensions.</li>
<li>Plateaus can make learning slow.
<ul>
<li>Plateaus is an area of fairly level high ground.</li>
<li>This is where algorithms like momentum and Adam helps.</li>
</ul></li>
</ul>
<h2 id="hyperparameter-tuning-batch-normalization-and-programming-frameworks">Hyperparameter tuning, Batch Normalization and Programming Frameworks</h2>
<h3 id="tuning-process">Tuning process</h3>
<ul>
<li>We need some steps to tune our Hyperparameters to get the best out of them.</li>
<li>So far the Hyperparameters importance are (As to Andrew Ng)
<ol type="1">
<li>Learning rate.</li>
<li>Mini-batch size.</li>
<li>No. of hidden units.</li>
<li>Momentum beta.</li>
<li>No. of layers.</li>
<li>Use learning rate decay?</li>
<li>Adam <code>beta1</code> &amp; <code>beta2</code></li>
<li>regularization lambda</li>
<li>Activation functions</li>
</ol></li>
<li>Its hard to decide which Hyperparameter is the more important in a problem. It depends much on your problem.</li>
<li>One of the ideas to tune is to make a box with <code>N</code> Hyperparameter settings and then try the <code>N</code> settings on your problem.</li>
<li>You can use Coarse to fine box and randomly initialize it the hyperparameters.
<ul>
<li>Then if you find some values that gives you a better values. Zoom into the box.</li>
</ul></li>
<li>This methods can be automated!</li>
</ul>
<h3 id="using-an-appropriate-scale-to-pick-hyperparameters">Using an appropriate scale to pick hyperparameters</h3>
<ul>
<li>If you have a specific range for a hyper parameter lets say from "a" to "b". Lets demonstrate the logarithmic scale, this will give you a good random points:
<ul>
<li><p>Calculate: <code>aLog = log(a)</code> <code># Ex. a = 0.0001 then aLog = -4</code></p>
<ul>
<li>Calculate: <code>bLog = log(b)</code> <code># Ex. b = 1  then bLog = 0</code></li>
</ul></li>
<li><p>Then: write this code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = (aLog-bLog) * np.random.rand() +    bLog</span><br><span class="line"># In our Ex the range would be from [-4, 0] because rand range [0,1)</span><br><span class="line">result = 10^r</span><br></pre></td></tr></table></figure>
<p>It uniformly samples values from [a, b] as r.</p></li>
</ul></li>
<li>If we want to use the last method on exploring on the "momentum beta":
<ul>
<li>Beta best range is from 0.9 to 0.999</li>
<li>You should scale this to <code>1-Beta = 0.001 to 0.1</code> and the use <code>a = 0.001</code> and <code>b = 0.1</code></li>
<li>And remember to subtract 1 from the resulted random value.</li>
</ul></li>
</ul>
<h3 id="hyperparameters-tuning-in-practice-pandas-vs.-caviar">Hyperparameters tuning in practice: Pandas vs. Caviar</h3>
<ul>
<li>If you don't have a much computational resources you will go thought "The baby sit model"
<ul>
<li>Run the model with different hyperparameters day by day.</li>
<li>Check at the end of each day if there are a progress or not.</li>
<li>You run one model at a time.</li>
<li>Called panda approach</li>
</ul></li>
<li>If you have computational resources, you can run some models in parallel and at the end of the day(s) you check the results.
<ul>
<li>Called Caviar model.</li>
</ul></li>
</ul>
<h3 id="normalizing-activations-in-a-network">Normalizing activations in a network</h3>
<ul>
<li>In the current evolution of deep learning an algorithm called <strong>Batch Normalization</strong> is so important.
<ul>
<li>Made by Sergey Ioffe and Christian Szegedy.</li>
</ul></li>
<li>Batch Normalization speeds up learning.</li>
<li>We discussed before that we can normalize input using the mean and variance method. This helped a lot in the shape of the cost function and reaching the minimum point in a more faster way!</li>
<li>The question is <em>For any hidden layer can we normalize <code>A[l]</code> to train <code>W[l]</code>, <code>b[l]</code> faster?</em>. This is what batch normalization is about.</li>
<li>Some papers normalize <code>Z[l]</code> and some normalize <code>A[l]</code>. Most of them uses <code>Z[l]</code> and recommended from Andrew Ng.</li>
<li>Algorithm
<ul>
<li>Given <code>Z[l] = [z(1) z(2) .. z(m)]</code> <code>#i = 1 to m (for one input)</code></li>
<li>Compute <code>mean[i] = 1/m * sum(z[i])</code></li>
<li>Compute <code>Variance[i] = 1/m * sum((z[i] - mean)^2)</code></li>
<li>Then <code>Z_norm[i] = (z(i) - mean) / np.sqrt(Variance + epsilon)</code>
<ul>
<li>Forcing the outputs to a specific distribution.</li>
</ul></li>
<li>Then <code>Z_dash[i] = alpha * Z_norm[i] + beta</code>
<ul>
<li>alpha and beta are learnable parameters.</li>
<li>Making the NN learn the distribution of the outputs.</li>
</ul></li>
</ul></li>
</ul>
<h3 id="fitting-batch-normalization-into-a-neural-network">Fitting Batch Normalization into a neural network</h3>
<ul>
<li>Using batch norm in 3 hidden layers NN:
<ul>
<li><img src="Images/bn.png" /></li>
</ul></li>
<li>Our NN parameters will be:
<ul>
<li><code>W[1]</code>, <code>b[1]</code>, <code>W[2]</code>, <code>b[2]</code>, <code>W[3]</code>, <code>b[3]</code>, <code>beta[1]</code>, <code>alpha[1]</code>, <code>beta[2]</code>, <code>alpha[2]</code>, <code>beta[3]</code>, <code>alpha[3]</code></li>
</ul></li>
<li>If you are using a deep learning framework, You won't have to implement batch norm yourself.
<ul>
<li>Ex. in Tensorflow you can add this line: <code>tf.nn.batch-normalization()</code></li>
</ul></li>
<li>If we are using batch norm the parameter <code>b[1]</code>, <code>b[2]</code>,.... Doesn't count because:
<ul>
<li><code>Z[l] = W[l]A[l-1] + b[l]</code></li>
<li><code>Z_N[l] = alpha[l] * Z_norm[l] + beta[l]</code></li>
<li>Taking the mean of a constant <code>b[l]</code> will eliminate the <code>b[l]</code></li>
</ul></li>
<li>So if you are using batch normalization, you can remove b[l] or make it always zero.</li>
<li>So the parameter will be Ws, betas, and alphas.</li>
<li>Shapes:
<ul>
<li><code>Z[l]</code> <code>#(n[l], m)</code>
<ul>
<li><code>alpha[l]</code> <code>#(n[l], m)</code></li>
<li><code>beta[l]</code> <code>#(n[l], m)</code></li>
</ul></li>
</ul></li>
</ul>
<h3 id="why-does-batch-normalization-work">Why does Batch normalization work</h3>
<ul>
<li>The first reason is the same reason as why we normalize X.</li>
<li>The second reason is that batch normalization reduces the problem of input values changing.</li>
<li>Batch norm does some regularization:
<ul>
<li>Each mini batch is scaled by the mean/variance computed of that mini batch.</li>
<li>-This adds some noise to the values <code>Z[l]</code> within that mini batch. Similar to dropout it adds some noise to each hidden layer activation</li>
<li>This has a slight regularization effect.</li>
</ul></li>
<li>To reduce this regularization effect you can make your mini batch bigger.</li>
<li>If you need regularization you cant just rely on that slight regularization you'll need to add your regularization (L2 or dropout).</li>
</ul>
<h3 id="batch-normalization-at-test-time">Batch normalization at test time</h3>
<ul>
<li>When we train a NN with Batch normalization, we compute the mean and the variance of the size of mini-batch.</li>
<li>In testing we have to test one by one example. The mean and the variance of one example doesn't make sense!</li>
<li>We have to compute an estimate value of mean and variance to use it in the testing time.</li>
<li>We can use the weighted average across the mini batches.</li>
<li>We will use the estimate values of the mean and variance to test.</li>
<li>There are another method to estimate this value called "Running average"</li>
<li>In practice don't worry as you will use a deep learning framework and it will contain some default of doing such a thing.</li>
</ul>
<h3 id="softmax-regression">Softmax Regression</h3>
<ul>
<li><p>Every example we have used so far are talking about classification on only two classes.</p></li>
<li><p>There are a generalization of logistic regression called Softmax regression that are more general.</p></li>
<li><p>For example if we are classifying dogs, cat, and none of that</p>
<ul>
<li>Dog <code>class = 1</code></li>
<li>Cat <code>class = 2</code></li>
<li>None <code>class = 0</code></li>
<li>To represent a dog vector <code>y = [1 0 0]</code></li>
<li>To represent a cat vector <code>y = [0 1 0]</code></li>
<li>To represent a none vector <code>y = [0 0 1]</code></li>
</ul></li>
<li><p>We will use these notations:</p>
<ul>
<li><code>C = no. Of classes</code></li>
<li>Range of classes is <code>(0,...C-1)</code></li>
<li>In output layer. <code>Ny = C</code></li>
</ul></li>
<li><p>Each of the output layers will contain a probability if the class is true.</p></li>
<li><p>In the last layer we will have to activate the Softmax activation function instead of the sigmoid activation.</p></li>
<li><p>Softmax activation equations:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = e^(Z[L])        # shape(C, m)</span><br><span class="line">A[L] = e^(Z[L]) / sum(t, C)       # shape(C, m)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="training-a-softmax-classifier">Training a Softmax classifier</h3>
<ul>
<li><p>There's an activation which is called hard max, which gets 1 for the maximum value and zeros for the others.</p>
<ul>
<li>If you are using NumPy, its <code>np.max</code> over the vertical axis.</li>
</ul></li>
<li><p>The Softmax name came from Softening the values and not harding them like hard max.</p></li>
<li><p>Softmax is a generalization of logistic regression with two or more classes.</p></li>
<li><p>The loss function used with Softmax:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L(y,y_dash) = -sum(y[i]*log(y_dash), C)</span><br></pre></td></tr></table></figure></li>
<li><p>The cost function used with Softmax:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">J(w[1], b[1], ....) = -1/m * (sum(L(y[i],y_dash[i]), m))</span><br></pre></td></tr></table></figure></li>
<li><p>Back propagation with Softmax:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dZ[L] = Y_dash - Y</span><br></pre></td></tr></table></figure></li>
<li><p>The derivative of Softmax is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y_dash( 1 - Y_dash)</span><br></pre></td></tr></table></figure></li>
<li><p>Example:</p>
<ul>
<li><img src="Images/07-_softmax.png" /></li>
</ul></li>
</ul>
<h3 id="deep-learning-frameworks">Deep learning frameworks</h3>
<ul>
<li>Its not practical to implement everything from scratch. Out last implementations was to know how NN works.</li>
<li>There are many good deep learning frameworks.</li>
<li>Deep learning is now in the phase of doing something with the frameworks and not from scratch to keep on going.</li>
<li>Here are some of the leading deep learning frameworks:
<ul>
<li>Caffe/ Caffe2</li>
<li>CNTK</li>
<li>DL4j</li>
<li>Keras</li>
<li>Lasagne</li>
<li>mxnet</li>
<li>PaddlePaddle</li>
<li>TensorFlow</li>
<li>Theano</li>
<li>Torch/Pytorch</li>
</ul></li>
<li>These frameworks are getting better month by month. Comparison between them can be found <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Comparison_of_deep_learning_software">here</a>.</li>
<li>How to choose deep learning framework:
<ul>
<li>Ease of programming (development and deployment)</li>
<li>Running speed</li>
<li>Truly open (Open source with good governance)</li>
</ul></li>
<li>Programing frameworks can not only shorten your coding time, but sometimes also perform optimizations that speed up your code.</li>
</ul>
<h3 id="tensorflow">TensorFlow</h3>
<ul>
<li><p>In this section we will learn the basic structure of TensorFlow.</p></li>
<li><p>Lets see how implement a minimization function:</p>
<ul>
<li><p>Function: <code>J(w) = w^2 - 10w + 25</code></p></li>
<li><p>the result should be <code>w = 5</code> as the function is <code>(w-5)^2 = 0</code></p></li>
<li><p>Code V1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">w = tf.Variable(0, dtype=tf.float32)                 # Creating a variable w</span><br><span class="line">cost = tf.add(tf.add(w**2, tf.multiply(-10.0, w)), 25.0)        # can be written as this [cost = w**2 - 10*w + 25]</span><br><span class="line">train = tf.train.GradientDescentOptimizer(0.01).minimize(cost)</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">session = tf.Session()</span><br><span class="line">session.run(init)</span><br><span class="line">session.run(w)    # Runs the definition of w, if you print this it will print zero</span><br><span class="line">session.run(train)</span><br><span class="line"></span><br><span class="line">print(&quot;W after one run: &quot;, session.run(w))</span><br><span class="line"></span><br><span class="line">for i in range(1000):</span><br><span class="line">    session.run(train)</span><br><span class="line"></span><br><span class="line">print(&quot;W after 1000 run: &quot;, session.run(w))</span><br></pre></td></tr></table></figure></li>
<li><p>Code V2 (we feed the inputs to the algorithm through coefficient):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">coefficient = np.array([[1.], [-10.], [25.]])</span><br><span class="line"></span><br><span class="line">x = tf.placeholder(tf.float32, [3, 1])</span><br><span class="line">w = tf.Variable(0, dtype=tf.float32)                 # Creating a variable w</span><br><span class="line">cost = x[0][0]*w**2 + x[1][0]*w + x[2][0]</span><br><span class="line"></span><br><span class="line">train = tf.train.GradientDescentOptimizer(0.01).minimize(cost)</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">session = tf.Session()</span><br><span class="line">session.run(init)</span><br><span class="line">session.run(w)    # Runs the definition of w, if you print this it will print zero</span><br><span class="line">session.run(train, feed_dict=&#123;x: coefficient&#125;)</span><br><span class="line"></span><br><span class="line">print(&quot;W after one run: &quot;, session.run(w))</span><br><span class="line"></span><br><span class="line">for i in range(1000):</span><br><span class="line">    session.run(train, feed_dict=&#123;x: coefficient&#125;)</span><br><span class="line"></span><br><span class="line">print(&quot;W after 1000 run: &quot;, session.run(w))</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>In TensorFlow you implement the forward propagation and TensorFlow will do the back propagation because it knows how to do it.</p></li>
<li><p>In TensorFlow a placeholder is a variable you can assign a value to later.</p></li>
<li><p>If you are using a mini-batch training you should change the <code>feed_dict=&#123;x: coefficient&#125;</code> to the current mini batch.</p></li>
<li><p>Almost all TensorFlow program uses this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with tf.Session() as session:             # Because its better at clean up.</span><br><span class="line">  session.run(init)</span><br><span class="line">  session.run(w)</span><br></pre></td></tr></table></figure></li>
<li><p>In deep learning frameworks there are a lot of things that you can do with one line of code like changing the optimizer.</p></li>
<li><p>Writing and running programs in TensorFlow has the following steps:</p>
<ol type="1">
<li>Create Tensors (variables) that are not yet executed/evaluated.</li>
<li>Write operations between those Tensors.</li>
<li>Initialize your Tensors.</li>
<li>Create a Session.</li>
<li>Run the Session. This will run the operations you'd written above.</li>
</ol></li>
<li><p>Instead of needing to write code to compute the cost function we know, we can use this line in TensorFlow :</p>
<p><code>tf.nn.sigmoid_cross_entropy_with_logits(logits = ...,  labels = ...)</code></p></li>
<li><p>To initialize weights in NN using TensorFlow use:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">W1 = tf.get_variable(&quot;W1&quot;, [25,12288], initializer = tf.contrib.layers.xavier_initializer(seed = 1))</span><br><span class="line"></span><br><span class="line">b1 = tf.get_variable(&quot;b1&quot;, [25,1], initializer = tf.zeros_initializer())</span><br></pre></td></tr></table></figure></li>
<li><p>For 3 layers NN, It is important to note that the forward propagation stops at <code>Z3</code>. The reason is that in TensorFlow the last linear layer output is given as input to the function computing the loss. Therefore, you don't need <code>A3</code>!</p></li>
<li><p>To reset the graph</p>
<ul>
<li><code>tf.reset_default_graph()</code></li>
</ul></li>
</ul>
<h2 id="extra-notes">Extra Notes</h2>
<ul>
<li>If you want a good papers in deep learning look at the ICLR proceedings (Or NIPS proceedings) and that will give you a really good view of the field.</li>
<li>Who is Yuanqing Lin?
<ul>
<li>Head of Baidu research.</li>
<li>First one to win ImageNet</li>
<li>Works in PaddlePaddle deep learning platform.</li>
</ul></li>
</ul>
<p><br><br> <br><br> These Notes were made by <a href="mailto:mma18@fayoum.edu.eg">Mahmoud Badry</a> <span class="citation" data-cites="2017">@2017</span></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Course-Note/" rel="tag"># Course Note</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Neural-Networks-and-Deep-Learning/2019/03/29/" rel="prev" title="Neural Networks and Deep Learning">
      <i class="fa fa-chevron-left"></i> Neural Networks and Deep Learning
    </a></div>
      <div class="post-nav-item">
    <a href="/Structuring-Machine-Learning-Projects/2019/03/29/" rel="next" title="Structuring Machine Learning Projects">
      Structuring Machine Learning Projects <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#table-of-contents"><span class="nav-number">1.</span> <span class="nav-text">Table of contents</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#course-summary"><span class="nav-number">2.</span> <span class="nav-text">Course summary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#practical-aspects-of-deep-learning"><span class="nav-number">3.</span> <span class="nav-text">Practical aspects of Deep Learning</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#train-dev-test-sets"><span class="nav-number">3.1.</span> <span class="nav-text">Train &#x2F; Dev &#x2F; Test sets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bias-variance"><span class="nav-number">3.2.</span> <span class="nav-text">Bias &#x2F; Variance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#basic-recipe-for-machine-learning"><span class="nav-number">3.3.</span> <span class="nav-text">Basic Recipe for Machine Learning</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#regularization"><span class="nav-number">3.4.</span> <span class="nav-text">Regularization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dropout-regularization"><span class="nav-number">3.5.</span> <span class="nav-text">Dropout Regularization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#understanding-dropout"><span class="nav-number">3.6.</span> <span class="nav-text">Understanding Dropout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#other-regularization-methods"><span class="nav-number">3.7.</span> <span class="nav-text">Other regularization methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#normalizing-inputs"><span class="nav-number">3.8.</span> <span class="nav-text">Normalizing inputs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vanishing-exploding-gradients"><span class="nav-number">3.9.</span> <span class="nav-text">Vanishing &#x2F; Exploding gradients</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weight-initialization-for-deep-networks"><span class="nav-number">3.10.</span> <span class="nav-text">Weight Initialization for Deep Networks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#numerical-approximation-of-gradients"><span class="nav-number">3.11.</span> <span class="nav-text">Numerical approximation of gradients</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gradient-checking-implementation-notes"><span class="nav-number">3.12.</span> <span class="nav-text">Gradient checking implementation notes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#optimization-algorithms"><span class="nav-number">4.</span> <span class="nav-text">Optimization algorithms</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mini-batch-gradient-descent"><span class="nav-number">4.1.</span> <span class="nav-text">Mini-batch gradient descent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#understanding-mini-batch-gradient-descent"><span class="nav-number">4.2.</span> <span class="nav-text">Understanding mini-batch gradient descent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exponentially-weighted-averages"><span class="nav-number">4.3.</span> <span class="nav-text">Exponentially weighted averages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#understanding-exponentially-weighted-averages"><span class="nav-number">4.4.</span> <span class="nav-text">Understanding exponentially weighted averages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bias-correction-in-exponentially-weighted-averages"><span class="nav-number">4.5.</span> <span class="nav-text">Bias correction in exponentially weighted averages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gradient-descent-with-momentum"><span class="nav-number">4.6.</span> <span class="nav-text">Gradient descent with momentum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rmsprop"><span class="nav-number">4.7.</span> <span class="nav-text">RMSprop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#adam-optimization-algorithm"><span class="nav-number">4.8.</span> <span class="nav-text">Adam optimization algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#learning-rate-decay"><span class="nav-number">4.9.</span> <span class="nav-text">Learning rate decay</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#the-problem-of-local-optima"><span class="nav-number">4.10.</span> <span class="nav-text">The problem of local optima</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hyperparameter-tuning-batch-normalization-and-programming-frameworks"><span class="nav-number">5.</span> <span class="nav-text">Hyperparameter tuning, Batch Normalization and Programming Frameworks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tuning-process"><span class="nav-number">5.1.</span> <span class="nav-text">Tuning process</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-an-appropriate-scale-to-pick-hyperparameters"><span class="nav-number">5.2.</span> <span class="nav-text">Using an appropriate scale to pick hyperparameters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hyperparameters-tuning-in-practice-pandas-vs.-caviar"><span class="nav-number">5.3.</span> <span class="nav-text">Hyperparameters tuning in practice: Pandas vs. Caviar</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#normalizing-activations-in-a-network"><span class="nav-number">5.4.</span> <span class="nav-text">Normalizing activations in a network</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fitting-batch-normalization-into-a-neural-network"><span class="nav-number">5.5.</span> <span class="nav-text">Fitting Batch Normalization into a neural network</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#why-does-batch-normalization-work"><span class="nav-number">5.6.</span> <span class="nav-text">Why does Batch normalization work</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#batch-normalization-at-test-time"><span class="nav-number">5.7.</span> <span class="nav-text">Batch normalization at test time</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#softmax-regression"><span class="nav-number">5.8.</span> <span class="nav-text">Softmax Regression</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#training-a-softmax-classifier"><span class="nav-number">5.9.</span> <span class="nav-text">Training a Softmax classifier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deep-learning-frameworks"><span class="nav-number">5.10.</span> <span class="nav-text">Deep learning frameworks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tensorflow"><span class="nav-number">5.11.</span> <span class="nav-text">TensorFlow</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extra-notes"><span class="nav-number">6.</span> <span class="nav-text">Extra Notes</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ruochi Zhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">219</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangruochi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangruochi" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zrc720@gmail.com" title="E-Mail → mailto:zrc720@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.healthinformaticslab.org/" title="http:&#x2F;&#x2F;www.healthinformaticslab.org" rel="noopener" target="_blank">HILab</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.shihaizhou.com/" title="http:&#x2F;&#x2F;www.shihaizhou.com" rel="noopener" target="_blank">Rose</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/cherish_CX/" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;cherish_CX&#x2F;" rel="noopener" target="_blank">Chunxia</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ruochi Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qW3MLcAgcX96sB6qbegeL7rP-gzGzoHsz',
      appKey     : 'GL6JvT9DgGxqYrY5Vj6bXVuv',
      placeholder: "Thank you for your reply",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'en' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
